"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-util";
exports.ids = ["vendor-chunks/ethereumjs-util"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n    return typeof obj;\n} : function(obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar _require = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\"), keccak224 = _require.keccak224, keccak384 = _require.keccak384, k256 = _require.keccak256, keccak512 = _require.keccak512;\nvar secp256k1 = __webpack_require__(/*! ./secp256k1-adapter */ \"(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-adapter.js\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar rlp = __webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer);\nObject.assign(exports, __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\"));\n/**\n * the max integer that this VM can handle (a ```BN```)\n * @var {BN} MAX_INTEGER\n */ exports.MAX_INTEGER = new BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256 (a ```BN```)\n * @var {BN} TWO_POW256\n */ exports.TWO_POW256 = new BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null (a ```String```)\n * @var {String} KECCAK256_NULL_S\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\nexports.SHA3_NULL_S = exports.KECCAK256_NULL_S;\n/**\n * Keccak-256 hash of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_NULL\n */ exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\nexports.SHA3_NULL = exports.KECCAK256_NULL;\n/**\n * Keccak-256 of an RLP of an empty array (a ```String```)\n * @var {String} KECCAK256_RLP_ARRAY_S\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\nexports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;\n/**\n * Keccak-256 of an RLP of an empty array (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP_ARRAY\n */ exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\nexports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;\n/**\n * Keccak-256 hash of the RLP of null  (a ```String```)\n * @var {String} KECCAK256_RLP_S\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\nexports.SHA3_RLP_S = exports.KECCAK256_RLP_S;\n/**\n * Keccak-256 hash of the RLP of null (a ```Buffer```)\n * @var {Buffer} KECCAK256_RLP\n */ exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, \"hex\");\nexports.SHA3_RLP = exports.KECCAK256_RLP;\n/**\n * [`BN`](https://github.com/indutny/bn.js)\n * @var {Function}\n */ exports.BN = BN;\n/**\n * [`rlp`](https://github.com/ethereumjs/rlp)\n * @var {Function}\n */ exports.rlp = rlp;\n/**\n * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)\n * @var {Object}\n */ exports.secp256k1 = secp256k1;\n/**\n * Returns a buffer filled with 0s\n * @method zeros\n * @param {Number} bytes  the number of bytes the buffer should be\n * @return {Buffer}\n */ exports.zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n  * Returns a zero address\n  * @method zeroAddress\n  * @return {String}\n  */ exports.zeroAddress = function() {\n    var addressLength = 20;\n    var zeroAddress = exports.zeros(addressLength);\n    return exports.bufferToHex(zeroAddress);\n};\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @method lsetLength\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @param {Boolean} [right=false] whether to start padding form the left or right\n * @return {Buffer|Array}\n */ exports.setLengthLeft = exports.setLength = function(msg, length, right) {\n    var buf = exports.zeros(length);\n    msg = exports.toBuffer(msg);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Buffer|Array} msg the value to pad\n * @param {Number} length the number of bytes the output should be\n * @return {Buffer|Array}\n */ exports.setLengthRight = function(msg, length) {\n    return exports.setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer` or an `Array`\n * @param {Buffer|Array|String} a\n * @return {Buffer|Array|String}\n */ exports.unpad = exports.stripZeros = function(a) {\n    a = exports.stripHexPrefix(a);\n    var first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param {*} v the value\n */ exports.toBuffer = function(v) {\n    if (!Buffer.isBuffer(v)) {\n        if (Array.isArray(v)) {\n            v = Buffer.from(v);\n        } else if (typeof v === \"string\") {\n            if (exports.isHexString(v)) {\n                v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), \"hex\");\n            } else {\n                v = Buffer.from(v);\n            }\n        } else if (typeof v === \"number\") {\n            v = exports.intToBuffer(v);\n        } else if (v === null || v === undefined) {\n            v = Buffer.allocUnsafe(0);\n        } else if (BN.isBN(v)) {\n            v = v.toArrayLike(Buffer);\n        } else if (v.toArray) {\n            // converts a BN to a Buffer\n            v = Buffer.from(v.toArray());\n        } else {\n            throw new Error(\"invalid type\");\n        }\n    }\n    return v;\n};\n/**\n * Converts a `Buffer` to a `Number`\n * @param {Buffer} buf\n * @return {Number}\n * @throws If the input number exceeds 53 bits.\n */ exports.bufferToInt = function(buf) {\n    return new BN(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a hex `String`\n * @param {Buffer} buf\n * @return {String}\n */ exports.bufferToHex = function(buf) {\n    buf = exports.toBuffer(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param {Buffer} num\n * @return {BN}\n */ exports.fromSigned = function(num) {\n    return new BN(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param {BN} num\n * @return {Buffer}\n */ exports.toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Creates Keccak hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the Keccak width\n * @return {Buffer}\n */ exports.keccak = function(a, bits) {\n    a = exports.toBuffer(a);\n    if (!bits) bits = 256;\n    switch(bits){\n        case 224:\n            {\n                return keccak224(a);\n            }\n        case 256:\n            {\n                return k256(a);\n            }\n        case 384:\n            {\n                return keccak384(a);\n            }\n        case 512:\n            {\n                return keccak512(a);\n            }\n        default:\n            {\n                throw new Error(\"Invald algorithm: keccak\" + bits);\n            }\n    }\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256)\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */ exports.keccak256 = function(a) {\n    return exports.keccak(a);\n};\n/**\n * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Number} [bits=256] the SHA-3 width\n * @return {Buffer}\n */ exports.sha3 = exports.keccak;\n/**\n * Creates SHA256 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */ exports.sha256 = function(a) {\n    a = exports.toBuffer(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates RIPEMD160 hash of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @param {Boolean} padded whether it should be padded to 256 bits or not\n * @return {Buffer}\n */ exports.ripemd160 = function(a, padded) {\n    a = exports.toBuffer(a);\n    var hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return exports.setLength(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input\n * @param {Buffer|Array|String|Number} a the input data\n * @return {Buffer}\n */ exports.rlphash = function(a) {\n    return exports.keccak(rlp.encode(a));\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n * @param {Buffer} privateKey\n * @return {Boolean}\n */ exports.isValidPrivate = function(privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Boolean}\n */ exports.isValidPublic = function(publicKey, sanitize) {\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param {Boolean} [sanitize=false] Accept public keys in other formats\n * @return {Buffer}\n */ exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {\n    pubKey = exports.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return exports.keccak(pubKey).slice(-20);\n};\n/**\n * Returns the ethereum public key of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */ var privateToPublic = exports.privateToPublic = function(privateKey) {\n    privateKey = exports.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n * @param {Buffer} publicKey\n * @return {Buffer}\n */ exports.importPublic = function(publicKey) {\n    publicKey = exports.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n};\n/**\n * ECDSA sign\n * @param {Buffer} msgHash\n * @param {Buffer} privateKey\n * @return {Object}\n */ exports.ecsign = function(msgHash, privateKey) {\n    var sig = secp256k1.sign(msgHash, privateKey);\n    var ret = {};\n    ret.r = sig.signature.slice(0, 32);\n    ret.s = sig.signature.slice(32, 64);\n    ret.v = sig.recovery + 27;\n    return ret;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n * @param message\n * @returns {Buffer} hash\n */ exports.hashPersonalMessage = function(message) {\n    var prefix = exports.toBuffer(\"\\x19Ethereum Signed Message:\\n\" + message.length.toString());\n    return exports.keccak(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\n/**\n * ECDSA public key recovery from signature\n * @param {Buffer} msgHash\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {Buffer} publicKey\n */ exports.ecrecover = function(msgHash, v, r, s) {\n    var signature = Buffer.concat([\n        exports.setLength(r, 32),\n        exports.setLength(s, 32)\n    ], 64);\n    var recovery = v - 27;\n    if (recovery !== 0 && recovery !== 1) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method\n * @param {Number} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @return {String} sig\n */ exports.toRpcSig = function(v, r, s) {\n    // NOTE: with potential introduction of chainId this might need to be updated\n    if (v !== 27 && v !== 28) {\n        throw new Error(\"Invalid recovery id\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053\n    return exports.bufferToHex(Buffer.concat([\n        exports.setLengthLeft(r, 32),\n        exports.setLengthLeft(s, 32),\n        exports.toBuffer(v - 27)\n    ]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n * @param {String} sig\n * @return {Object}\n */ exports.fromRpcSig = function(sig) {\n    sig = exports.toBuffer(sig);\n    // NOTE: with potential introduction of chainId this might need to be updated\n    if (sig.length !== 65) {\n        throw new Error(\"Invalid signature length\");\n    }\n    var v = sig[64];\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: sig.slice(0, 32),\n        s: sig.slice(32, 64)\n    };\n};\n/**\n * Returns the ethereum address of a given private key\n * @param {Buffer} privateKey A private key must be 256 bits wide\n * @return {Buffer}\n */ exports.privateToAddress = function(privateKey) {\n    return exports.publicToAddress(privateToPublic(privateKey));\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too\n * @param {String} address\n * @return {Boolean}\n */ exports.isValidAddress = function(address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n  * Checks if a given address is a zero address\n  * @method isZeroAddress\n  * @param {String} address\n  * @return {Boolean}\n  */ exports.isZeroAddress = function(address) {\n    var zeroAddress = exports.zeroAddress();\n    return zeroAddress === exports.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address\n * @param {String} address\n * @return {String}\n */ exports.toChecksumAddress = function(address) {\n    address = exports.stripHexPrefix(address).toLowerCase();\n    var hash = exports.keccak(address).toString(\"hex\");\n    var ret = \"0x\";\n    for(var i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address\n * @param {Buffer} address\n * @return {Boolean}\n */ exports.isValidChecksumAddress = function(address) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;\n};\n/**\n * Generates an address of a newly created contract\n * @param {Buffer} from the address which is creating this new address\n * @param {Buffer} nonce the nonce of the from account\n * @return {Buffer}\n */ exports.generateAddress = function(from, nonce) {\n    from = exports.toBuffer(from);\n    nonce = new BN(nonce);\n    if (nonce.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        nonce = null;\n    } else {\n        nonce = Buffer.from(nonce.toArray());\n    }\n    // Only take the lower 160bits of the hash\n    return exports.rlphash([\n        from,\n        nonce\n    ]).slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium)\n * @param {Buffer|String} address\n * @return {Boolean}\n */ exports.isPrecompiled = function(address) {\n    var a = exports.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\"\n * @param {String} str\n * @return {String}\n */ exports.addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return exports.isHexPrefixed(str) ? str : \"0x\" + str;\n};\n/**\n * Validate ECDSA signature\n * @method isValidSignature\n * @param {Buffer} v\n * @param {Buffer} r\n * @param {Buffer} s\n * @param {Boolean} [homestead=true]\n * @return {Boolean}\n */ exports.isValidSignature = function(v, r, s, homestead) {\n    var SECP256K1_N_DIV_2 = new BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    var SECP256K1_N = new BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (v !== 27 && v !== 28) {\n        return false;\n    }\n    r = new BN(r);\n    s = new BN(s);\n    if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON\n * @param {Buffer|Array} ba\n * @return {Array|String|null}\n */ exports.baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return \"0x\" + ba.toString(\"hex\");\n    } else if (ba instanceof Array) {\n        var array = [];\n        for(var i = 0; i < ba.length; i++){\n            array.push(exports.baToJSON(ba[i]));\n        }\n        return array;\n    }\n};\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param {Object} self the `Object` to define properties on\n * @param {Array} fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param {*} data data to be validated against the definitions\n */ exports.defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label) {\n        if (label) {\n            var obj = {};\n            self._fields.forEach(function(field) {\n                obj[field] = \"0x\" + self[field].toString(\"hex\");\n            });\n            return obj;\n        }\n        return exports.baToJSON(this.raw);\n    };\n    self.serialize = function serialize() {\n        return rlp.encode(self.raw);\n    };\n    fields.forEach(function(field, i) {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = exports.toBuffer(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = exports.stripZeros(v);\n                assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from(exports.stripHexPrefix(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach(function(d, i) {\n                self[self._fields[i]] = exports.toBuffer(d);\n            });\n        } else if ((typeof data === \"undefined\" ? \"undefined\" : _typeof(data)) === \"object\") {\n            var keys = Object.keys(data);\n            fields.forEach(function(field) {\n                if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxVQUFVLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssV0FBVyxTQUFVQyxHQUFHO0lBQUksT0FBTyxPQUFPQTtBQUFLLElBQUksU0FBVUEsR0FBRztJQUFJLE9BQU9BLE9BQU8sT0FBT0YsV0FBVyxjQUFjRSxJQUFJQyxXQUFXLEtBQUtILFVBQVVFLFFBQVFGLE9BQU9JLFNBQVMsR0FBRyxXQUFXLE9BQU9GO0FBQUs7QUFFM1EsSUFBSUcsV0FBV0MsbUJBQU9BLENBQUMsNkZBQ25CQyxZQUFZRixTQUFTRSxTQUFTLEVBQzlCQyxZQUFZSCxTQUFTRyxTQUFTLEVBQzlCQyxPQUFPSixTQUFTSyxTQUFTLEVBQ3pCQyxZQUFZTixTQUFTTSxTQUFTO0FBRWxDLElBQUlDLFlBQVlOLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlPLFNBQVNQLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlRLE1BQU1SLG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlTLEtBQUtULG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlVLGFBQWFWLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlXLFNBQVNYLDRGQUE2QjtBQUMxQ1ksT0FBT0MsTUFBTSxDQUFDQyxTQUFTZCxtQkFBT0EsQ0FBQztBQUUvQjs7O0NBR0MsR0FDRGMsbUJBQW1CLEdBQUcsSUFBSUwsR0FBRyxvRUFBb0U7QUFFakc7OztDQUdDLEdBQ0RLLGtCQUFrQixHQUFHLElBQUlMLEdBQUcscUVBQXFFO0FBRWpHOzs7Q0FHQyxHQUNESyx3QkFBd0IsR0FBRztBQUMzQkEsbUJBQW1CLEdBQUdBLFFBQVFHLGdCQUFnQjtBQUU5Qzs7O0NBR0MsR0FDREgsc0JBQXNCLEdBQUdILE9BQU9TLElBQUksQ0FBQ04sUUFBUUcsZ0JBQWdCLEVBQUU7QUFDL0RILGlCQUFpQixHQUFHQSxRQUFRSyxjQUFjO0FBRTFD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LElBQUksQ0FBQ04sUUFBUW9DLGNBQWMsQ0FBQ2dHLE9BQU87UUFDbkQ7UUFFQSxJQUFJdkksT0FBTzJDLFFBQVEsQ0FBQzRGLE9BQU87WUFDekJBLE9BQU8xSSxJQUFJOEosTUFBTSxDQUFDcEI7UUFDcEI7UUFFQSxJQUFJM0YsTUFBTUMsT0FBTyxDQUFDMEYsT0FBTztZQUN2QixJQUFJQSxLQUFLMUcsTUFBTSxHQUFHd0csS0FBS0ksT0FBTyxDQUFDNUcsTUFBTSxFQUFFO2dCQUNyQyxNQUFNLElBQUl3QixNQUFNO1lBQ2xCO1lBRUEsc0NBQXNDO1lBQ3RDa0YsS0FBS0ssT0FBTyxDQUFDLFNBQVVnQixDQUFDLEVBQUU1QyxDQUFDO2dCQUN6QnFCLElBQUksQ0FBQ0EsS0FBS0ksT0FBTyxDQUFDekIsRUFBRSxDQUFDLEdBQUc3RyxRQUFRNkIsUUFBUSxDQUFDNEg7WUFDM0M7UUFDRixPQUFPLElBQUksQ0FBQyxPQUFPckIsU0FBUyxjQUFjLGNBQWN6SixRQUFReUosS0FBSSxNQUFPLFVBQVU7WUFDbkYsSUFBSXNCLE9BQU81SixPQUFPNEosSUFBSSxDQUFDdEI7WUFDdkJELE9BQU9NLE9BQU8sQ0FBQyxTQUFVQyxLQUFLO2dCQUM1QixJQUFJZ0IsS0FBS0MsT0FBTyxDQUFDakIsTUFBTUUsSUFBSSxNQUFNLENBQUMsR0FBR1YsSUFBSSxDQUFDUSxNQUFNRSxJQUFJLENBQUMsR0FBR1IsSUFBSSxDQUFDTSxNQUFNRSxJQUFJLENBQUM7Z0JBQ3hFLElBQUljLEtBQUtDLE9BQU8sQ0FBQ2pCLE1BQU1hLEtBQUssTUFBTSxDQUFDLEdBQUdyQixJQUFJLENBQUNRLE1BQU1hLEtBQUssQ0FBQyxHQUFHbkIsSUFBSSxDQUFDTSxNQUFNYSxLQUFLLENBQUM7WUFDN0U7UUFDRixPQUFPO1lBQ0wsTUFBTSxJQUFJckcsTUFBTTtRQUNsQjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcz8wOGJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyksXG4gICAga2VjY2FrMjI0ID0gX3JlcXVpcmUua2VjY2FrMjI0LFxuICAgIGtlY2NhazM4NCA9IF9yZXF1aXJlLmtlY2NhazM4NCxcbiAgICBrMjU2ID0gX3JlcXVpcmUua2VjY2FrMjU2LFxuICAgIGtlY2NhazUxMiA9IF9yZXF1aXJlLmtlY2NhazUxMjtcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWFkYXB0ZXInKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBybHAgPSByZXF1aXJlKCdybHAnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIHJlcXVpcmUoJ2V0aGpzLXV0aWwnKSk7XG5cbi8qKlxuICogdGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlIChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IE1BWF9JTlRFR0VSXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG5cbi8qKlxuICogMl4yNTYgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gVFdPX1BPVzI1NlxuICovXG5leHBvcnRzLlRXT19QT1cyNTYgPSBuZXcgQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMTYpO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X05VTExfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSAnYzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG5leHBvcnRzLlNIQTNfTlVMTF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X05VTExcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9BUlJBWV9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWV9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQX0FSUkFZXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuZXhwb3J0cy5TSEEzX1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFAgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFA7XG5cbi8qKlxuICogW2BCTmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuQk4gPSBCTjtcblxuLyoqXG4gKiBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscClcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLnJscCA9IHJscDtcblxuLyoqXG4gKiBbYHNlY3AyNTZrMWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvKVxuICogQHZhciB7T2JqZWN0fVxuICovXG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzXG4gKiBAbWV0aG9kIHplcm9zXG4gKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy56ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcblxuLyoqXG4gICogUmV0dXJucyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgemVyb0FkZHJlc3NcbiAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleCh6ZXJvQWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIExlZnQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAbWV0aG9kIGxzZXRMZW5ndGhcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtyaWdodD1mYWxzZV0gd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gIHZhciBidWYgPSBleHBvcnRzLnplcm9zKGxlbmd0aCk7XG4gIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgaWYgKHJpZ2h0KSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJpZ2h0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcblxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCBvciBhbiBgQXJyYXlgXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd9IGFcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheXxTdHJpbmd9XG4gKi9cbmV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhKTtcbiAgdmFyIGZpcnN0ID0gYVswXTtcbiAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICBhID0gYS5zbGljZSgxKTtcbiAgICBmaXJzdCA9IGFbMF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHsqfSB2IHRoZSB2YWx1ZVxuICovXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20oZXhwb3J0cy5wYWRUb0V2ZW4oZXhwb3J0cy5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgdiA9IGV4cG9ydHMuaW50VG9CdWZmZXIodik7XG4gICAgfSBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9IGVsc2UgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgIHYgPSB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmBcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbnVtXG4gKiBAcmV0dXJuIHtCTn1cbiAqL1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0JOfSBudW1cbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy50b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgS2VjY2FrIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIGlmICghYml0cykgYml0cyA9IDI1NjtcblxuICBzd2l0Y2ggKGJpdHMpIHtcbiAgICBjYXNlIDIyNDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazIyNChhKTtcbiAgICAgIH1cbiAgICBjYXNlIDI1NjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGsyNTYoYSk7XG4gICAgICB9XG4gICAgY2FzZSAzODQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWszODQoYSk7XG4gICAgICB9XG4gICAgY2FzZSA1MTI6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWs1MTIoYSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWsnICsgYml0cyk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NilcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoYSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgKEtlY2NhaykgaGFzaCBvZiB0aGUgaW5wdXQgW09CU09MRVRFXVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIFNIQS0zIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMyA9IGV4cG9ydHMua2VjY2FrO1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhZGRlZCB3aGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG4gIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgoaGFzaCwgMzIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5ybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUpIHtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gIH1cblxuICBpZiAoIXNhbml0aXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplKSB7XG4gIHB1YktleSA9IGV4cG9ydHMudG9CdWZmZXIocHViS2V5KTtcbiAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHViS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgYXNzZXJ0KHB1YktleS5sZW5ndGggPT09IDY0KTtcbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcHJpdmF0ZUtleSA9IGV4cG9ydHMudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgcHVibGljS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJsaWNLZXkpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gcHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBFQ0RTQSBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5lY3NpZ24gPSBmdW5jdGlvbiAobXNnSGFzaCwgcHJpdmF0ZUtleSkge1xuICB2YXIgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG5cbiAgdmFyIHJldCA9IHt9O1xuICByZXQuciA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICByZXQucyA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgcmV0LnYgPSBzaWcucmVjb3ZlcnkgKyAyNztcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gbWVzc2FnZVxuICogQHJldHVybnMge0J1ZmZlcn0gaGFzaFxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICB2YXIgcHJlZml4ID0gZXhwb3J0cy50b0J1ZmZlcignXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgbWVzc2FnZS5sZW5ndGgudG9TdHJpbmcoKSk7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHB1YmxpY0tleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzKSB7XG4gIHZhciBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoKHMsIDMyKV0sIDY0KTtcbiAgdmFyIHJlY292ZXJ5ID0gdiAtIDI3O1xuICBpZiAocmVjb3ZlcnkgIT09IDAgJiYgcmVjb3ZlcnkgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgfVxuICB2YXIgc2VuZGVyUHViS2V5ID0gc2VjcDI1NmsxLnJlY292ZXIobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSk7XG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHNpZ1xuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlY292ZXJ5IGlkJyk7XG4gIH1cblxuICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAvLyBGSVhNRTogdGhpcyBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aExlZnQociwgMzIpLCBleHBvcnRzLnNldExlbmd0aExlZnQocywgMzIpLCBleHBvcnRzLnRvQnVmZmVyKHYgLSAyNyldKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICBzaWcgPSBleHBvcnRzLnRvQnVmZmVyKHNpZyk7XG5cbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHNpZy5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhciB2ID0gc2lnWzY0XTtcbiAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gIGlmICh2IDwgMjcpIHtcbiAgICB2ICs9IDI3O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2OiB2LFxuICAgIHI6IHNpZy5zbGljZSgwLCAzMiksXG4gICAgczogc2lnLnNsaWNlKDMyLCA2NClcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MocHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvb1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gKC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpXG4gICk7XG59O1xuXG4vKipcbiAgKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCBpc1plcm9BZGRyZXNzXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcygpO1xuICByZXR1cm4gemVyb0FkZHJlc3MgPT09IGV4cG9ydHMuYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNoID0gZXhwb3J0cy5rZWNjYWsoYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgcmV0ID0gJzB4JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3RcbiAqIEBwYXJhbSB7QnVmZmVyfSBmcm9tIHRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBub25jZSB0aGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICBmcm9tID0gZXhwb3J0cy50b0J1ZmZlcihmcm9tKTtcbiAgbm9uY2UgPSBuZXcgQk4obm9uY2UpO1xuXG4gIGlmIChub25jZS5pc1plcm8oKSkge1xuICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAvLyByZWFkIHRoZSBSTFAgZG9jdW1lbnRhdGlvbiBmb3IgYW4gYW5zd2VyIGlmIHlvdSBkYXJlXG4gICAgbm9uY2UgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vbmNlID0gQnVmZmVyLmZyb20obm9uY2UudG9BcnJheSgpKTtcbiAgfVxuXG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5ybHBoYXNoKFtmcm9tLCBub25jZV0pLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYWRkcmVzcyBiZWxvbmdzIHRvIGEgcHJlY29tcGlsZWQgYWNjb3VudCAoQnl6YW50aXVtKVxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzUHJlY29tcGlsZWQgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgYSA9IGV4cG9ydHMudW5wYWQoYWRkcmVzcyk7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcblxuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBFQ0RTQSBzaWduYXR1cmVcbiAqIEBtZXRob2QgaXNWYWxpZFNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHBhcmFtIHtCb29sZWFufSBbaG9tZXN0ZWFkPXRydWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWQpIHtcbiAgdmFyIFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IEJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xuICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG5cbiAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByID0gbmV3IEJOKHIpO1xuICBzID0gbmV3IEJOKHMpO1xuXG4gIGlmIChyLmlzWmVybygpIHx8IHIuZ3QoU0VDUDI1NksxX04pIHx8IHMuaXNaZXJvKCkgfHwgcy5ndChTRUNQMjU2SzFfTikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaG9tZXN0ZWFkID09PSBmYWxzZSAmJiBuZXcgQk4ocykuY21wKFNFQ1AyNTZLMV9OX0RJVl8yKSA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IGJhXG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd8bnVsbH1cbiAqL1xuZXhwb3J0cy5iYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgIHJldHVybiAnMHgnICsgYmEudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKGV4cG9ydHMuYmFUb0pTT04oYmFbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59O1xuXG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0geyp9IGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICBzZWxmLnJhdyA9IFtdO1xuICBzZWxmLl9maWVsZHMgPSBbXTtcblxuICAvLyBhdHRhY2ggdGhlIGB0b0pTT05gXG4gIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgb2JqW2ZpZWxkXSA9ICcweCcgKyBzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmJhVG9KU09OKHRoaXMucmF3KTtcbiAgfTtcblxuICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gIH07XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgdiA9IGV4cG9ydHMudG9CdWZmZXIodik7XG5cbiAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHYgPSBleHBvcnRzLnN0cmlwWmVyb3Modik7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3Qgbm90IGhhdmUgbW9yZSAnICsgZmllbGQubGVuZ3RoICsgJyBieXRlcycpO1xuICAgICAgfSBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgJyArIGZpZWxkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmF3W2ldID0gdjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgc2V0OiBzZXR0ZXJcbiAgICB9KTtcblxuICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXhwb3J0cy5zdHJpcEhleFByZWZpeChkYXRhKSwgJ2hleCcpO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBybHAuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgbnVtYmVyIG9mIGZpZWxkcyBpbiBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgc2VsZltzZWxmLl9maWVsZHNbaV1dID0gZXhwb3J0cy50b0J1ZmZlcihkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKSBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKSBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgfVxuICB9XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9yZXF1aXJlIiwicmVxdWlyZSIsImtlY2NhazIyNCIsImtlY2NhazM4NCIsImsyNTYiLCJrZWNjYWsyNTYiLCJrZWNjYWs1MTIiLCJzZWNwMjU2azEiLCJhc3NlcnQiLCJybHAiLCJCTiIsImNyZWF0ZUhhc2giLCJCdWZmZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJleHBvcnRzIiwiTUFYX0lOVEVHRVIiLCJUV09fUE9XMjU2IiwiS0VDQ0FLMjU2X05VTExfUyIsIlNIQTNfTlVMTF9TIiwiS0VDQ0FLMjU2X05VTEwiLCJmcm9tIiwiU0hBM19OVUxMIiwiS0VDQ0FLMjU2X1JMUF9BUlJBWV9TIiwiU0hBM19STFBfQVJSQVlfUyIsIktFQ0NBSzI1Nl9STFBfQVJSQVkiLCJTSEEzX1JMUF9BUlJBWSIsIktFQ0NBSzI1Nl9STFBfUyIsIlNIQTNfUkxQX1MiLCJLRUNDQUsyNTZfUkxQIiwiU0hBM19STFAiLCJ6ZXJvcyIsImJ5dGVzIiwiYWxsb2NVbnNhZmUiLCJmaWxsIiwiemVyb0FkZHJlc3MiLCJhZGRyZXNzTGVuZ3RoIiwiYnVmZmVyVG9IZXgiLCJzZXRMZW5ndGhMZWZ0Iiwic2V0TGVuZ3RoIiwibXNnIiwibGVuZ3RoIiwicmlnaHQiLCJidWYiLCJ0b0J1ZmZlciIsImNvcHkiLCJzbGljZSIsInNldExlbmd0aFJpZ2h0IiwidW5wYWQiLCJzdHJpcFplcm9zIiwiYSIsInN0cmlwSGV4UHJlZml4IiwiZmlyc3QiLCJ0b1N0cmluZyIsInYiLCJpc0J1ZmZlciIsIkFycmF5IiwiaXNBcnJheSIsImlzSGV4U3RyaW5nIiwicGFkVG9FdmVuIiwiaW50VG9CdWZmZXIiLCJ1bmRlZmluZWQiLCJpc0JOIiwidG9BcnJheUxpa2UiLCJ0b0FycmF5IiwiRXJyb3IiLCJidWZmZXJUb0ludCIsInRvTnVtYmVyIiwiZnJvbVNpZ25lZCIsIm51bSIsImZyb21Ud29zIiwidG9VbnNpZ25lZCIsInRvVHdvcyIsImtlY2NhayIsImJpdHMiLCJzaGEzIiwic2hhMjU2IiwidXBkYXRlIiwiZGlnZXN0IiwicmlwZW1kMTYwIiwicGFkZGVkIiwiaGFzaCIsInJscGhhc2giLCJlbmNvZGUiLCJpc1ZhbGlkUHJpdmF0ZSIsInByaXZhdGVLZXkiLCJwcml2YXRlS2V5VmVyaWZ5IiwiaXNWYWxpZFB1YmxpYyIsInB1YmxpY0tleSIsInNhbml0aXplIiwicHVibGljS2V5VmVyaWZ5IiwiY29uY2F0IiwicHViVG9BZGRyZXNzIiwicHVibGljVG9BZGRyZXNzIiwicHViS2V5IiwicHVibGljS2V5Q29udmVydCIsInByaXZhdGVUb1B1YmxpYyIsInB1YmxpY0tleUNyZWF0ZSIsImltcG9ydFB1YmxpYyIsImVjc2lnbiIsIm1zZ0hhc2giLCJzaWciLCJzaWduIiwicmV0IiwiciIsInNpZ25hdHVyZSIsInMiLCJyZWNvdmVyeSIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJtZXNzYWdlIiwicHJlZml4IiwiZWNyZWNvdmVyIiwic2VuZGVyUHViS2V5IiwicmVjb3ZlciIsInRvUnBjU2lnIiwiZnJvbVJwY1NpZyIsInByaXZhdGVUb0FkZHJlc3MiLCJpc1ZhbGlkQWRkcmVzcyIsImFkZHJlc3MiLCJ0ZXN0IiwiaXNaZXJvQWRkcmVzcyIsImFkZEhleFByZWZpeCIsInRvQ2hlY2tzdW1BZGRyZXNzIiwidG9Mb3dlckNhc2UiLCJpIiwicGFyc2VJbnQiLCJ0b1VwcGVyQ2FzZSIsImlzVmFsaWRDaGVja3N1bUFkZHJlc3MiLCJnZW5lcmF0ZUFkZHJlc3MiLCJub25jZSIsImlzWmVybyIsImlzUHJlY29tcGlsZWQiLCJzdHIiLCJpc0hleFByZWZpeGVkIiwiaXNWYWxpZFNpZ25hdHVyZSIsImhvbWVzdGVhZCIsIlNFQ1AyNTZLMV9OX0RJVl8yIiwiU0VDUDI1NksxX04iLCJndCIsImNtcCIsImJhVG9KU09OIiwiYmEiLCJhcnJheSIsInB1c2giLCJkZWZpbmVQcm9wZXJ0aWVzIiwic2VsZiIsImZpZWxkcyIsImRhdGEiLCJyYXciLCJfZmllbGRzIiwidG9KU09OIiwibGFiZWwiLCJmb3JFYWNoIiwiZmllbGQiLCJzZXJpYWxpemUiLCJuYW1lIiwiZ2V0dGVyIiwic2V0dGVyIiwiYWxsb3daZXJvIiwiYWxsb3dMZXNzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0Iiwic2V0IiwiZGVmYXVsdCIsImFsaWFzIiwiZGVjb2RlIiwiZCIsImtleXMiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-adapter.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/secp256k1-adapter.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar secp256k1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nvar secp256k1v3 = __webpack_require__(/*! ./secp256k1-lib/index */ \"(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/index.js\");\nvar der = __webpack_require__(/*! ./secp256k1-lib/der */ \"(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/der.js\");\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */ var privateKeyVerify = function privateKeyVerify(privateKey) {\n    // secp256k1 v4 version throws when privateKey length is not 32\n    if (privateKey.length !== 32) {\n        return false;\n    }\n    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */ var privateKeyExport = function privateKeyExport(privateKey, compressed) {\n    // privateKeyExport method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    if (privateKey.length !== 32) {\n        throw new RangeError(\"private key length is invalid\");\n    }\n    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n    return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ var privateKeyImport = function privateKeyImport(privateKey) {\n    // privateKeyImport method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    privateKey = der.privateKeyImport(privateKey);\n    if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\n        return privateKey;\n    }\n    throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ var privateKeyNegate = function privateKeyNegate(privateKey) {\n    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ var privateKeyModInverse = function privateKeyModInverse(privateKey) {\n    if (privateKey.length !== 32) {\n        throw new Error(\"private key length is invalid\");\n    }\n    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */ var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */ var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */ var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */ var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */ var publicKeyVerify = function publicKeyVerify(publicKey) {\n    // secp256k1 v4 version throws when publicKey length is not 33 or 65\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */ var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */ var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */ var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\n    var keys = [];\n    publicKeys.forEach(function(publicKey) {\n        keys.push(Uint8Array.from(publicKey));\n    });\n    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */ var signatureNormalize = function signatureNormalize(signature) {\n    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */ var signatureExport = function signatureExport(signature) {\n    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */ var signatureImport = function signatureImport(signature) {\n    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */ var signatureImportLax = function signatureImportLax(signature) {\n    // signatureImportLax method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure that signature is greater than 0\n    if (signature.length === 0) {\n        throw new RangeError(\"signature length is invalid\");\n    }\n    var sigObj = der.signatureImportLax(signature);\n    if (sigObj === null) {\n        throw new Error(\"couldn't parse DER signature\");\n    }\n    return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */ var sign = function sign(message, privateKey, options) {\n    if (options === null) {\n        throw new TypeError(\"options should be an Object\");\n    }\n    var signOptions = void 0;\n    if (options) {\n        signOptions = {};\n        if (options.data === null) {\n            throw new TypeError(\"options.data should be a Buffer\");\n        }\n        if (options.data) {\n            // validate option.data length\n            if (options.data.length !== 32) {\n                throw new RangeError(\"options.data length is invalid\");\n            }\n            signOptions.data = new Uint8Array(options.data);\n        }\n        if (options.noncefn === null) {\n            throw new TypeError(\"options.noncefn should be a Function\");\n        }\n        if (options.noncefn) {\n            //  convert option.noncefn function signature\n            signOptions.noncefn = function(message, privateKey, algo, data, attempt) {\n                var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n                var bufferData = data != null ? Buffer.from(data) : null;\n                var buffer = Buffer.from(\"\");\n                if (options.noncefn) {\n                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n                }\n                return Uint8Array.from(buffer);\n            };\n        }\n    }\n    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n    return {\n        signature: Buffer.from(sig.signature),\n        recovery: sig.recid\n    };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */ var verify = function verify(message, signature, publicKey) {\n    // note: secp256k1 v4 verify method has a different argument order\n    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */ var recover = function recover(message, signature, recid, compressed) {\n    // note: secp256k1 v4 recover method has a different argument order\n    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ var ecdh = function ecdh(publicKey, privateKey) {\n    // note: secp256k1 v3 doesn't allow optional parameter\n    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n/**\n * Compute an EC Diffie-Hellman secret and return public key as result\n * @method ecdhUnsafe\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */ var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\n    // ecdhUnsafe method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure valid publicKey length\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        throw new RangeError(\"public key length is invalid\");\n    }\n    // ensure valid privateKey length\n    if (privateKey.length !== 32) {\n        throw new RangeError(\"private key length is invalid\");\n    }\n    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\nmodule.exports = {\n    privateKeyVerify: privateKeyVerify,\n    privateKeyExport: privateKeyExport,\n    privateKeyImport: privateKeyImport,\n    privateKeyNegate: privateKeyNegate,\n    privateKeyModInverse: privateKeyModInverse,\n    privateKeyTweakAdd: privateKeyTweakAdd,\n    privateKeyTweakMul: privateKeyTweakMul,\n    publicKeyCreate: publicKeyCreate,\n    publicKeyConvert: publicKeyConvert,\n    publicKeyVerify: publicKeyVerify,\n    publicKeyTweakAdd: publicKeyTweakAdd,\n    publicKeyTweakMul: publicKeyTweakMul,\n    publicKeyCombine: publicKeyCombine,\n    signatureNormalize: signatureNormalize,\n    signatureExport: signatureExport,\n    signatureImport: signatureImport,\n    signatureImportLax: signatureImportLax,\n    sign: sign,\n    verify: verify,\n    recover: recover,\n    ecdh: ecdh,\n    ecdhUnsafe: ecdhUnsafe\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUV4QixJQUFJQyxjQUFjRCxtQkFBT0EsQ0FBQztBQUMxQixJQUFJRSxNQUFNRixtQkFBT0EsQ0FBQztBQUVsQjs7Ozs7Q0FLQyxHQUNELElBQUlHLG1CQUFtQixTQUFTQSxpQkFBaUJDLFVBQVU7SUFDekQsK0RBQStEO0lBQy9ELElBQUlBLFdBQVdDLE1BQU0sS0FBSyxJQUFJO1FBQzVCLE9BQU87SUFDVDtJQUVBLE9BQU9OLFVBQVVJLGdCQUFnQixDQUFDRyxXQUFXQyxJQUFJLENBQUNIO0FBQ3BEO0FBRUE7Ozs7OztDQU1DLEdBQ0QsSUFBSUksbUJBQW1CLFNBQVNBLGlCQUFpQkosVUFBVSxFQUFFSyxVQUFVO0lBQ3JFLDhEQUE4RDtJQUM5RCxxQ0FBcUM7SUFDckMsSUFBSUwsV0FBV0MsTUFBTSxLQUFLLElBQUk7UUFDNUIsTUFBTSxJQUFJSyxXQUFXO0lBQ3ZCO0lBRUEsSUFBSUMsWUFBWVYsWUFBWU8sZ0JBQWdCLENBQUNKLFlBQVlLO0lBRXpELE9BQU9QLElBQUlNLGdCQUFnQixDQUFDSixZQUFZTyxXQUFXRjtBQUNyRDtBQUVBOzs7OztDQUtDLEdBRUQsSUFBSUcsbUJBQW1CLFNBQVNBLGlCQUFpQlIsVUFBVTtJQUN6RCw4REFBOEQ7SUFDOUQscUNBQXFDO0lBQ3JDQSxhQUFhRixJQUFJVSxnQkFBZ0IsQ0FBQ1I7SUFDbEMsSUFBSUEsZUFBZSxRQUFRQSxXQUFXQyxNQUFNLEtBQUssTUFBTUYsaUJBQWlCQyxhQUFhO1FBQ25GLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNLElBQUlTLE1BQU07QUFDbEI7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlDLG1CQUFtQixTQUFTQSxpQkFBaUJWLFVBQVU7SUFDekQsT0FBT1csT0FBT1IsSUFBSSxDQUFDUixVQUFVZSxnQkFB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b0JBQW9CQTtJQUVwQkUsTUFBTUE7SUFDTmdCLFFBQVFBO0lBQ1JFLFNBQVNBO0lBRVRFLE1BQU1BO0lBQ05DLFlBQVlBO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtYWRhcHRlci5qcz8xZDcyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEnKTtcblxudmFyIHNlY3AyNTZrMXYzID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2luZGV4Jyk7XG52YXIgZGVyID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2RlcicpO1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwcml2YXRlS2V5XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHJpdmF0ZUtleVZlcmlmeSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gcHJpdmF0ZUtleUV4cG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcblxuICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG5cbi8qKlxuICogSW1wb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cblxudmFyIHByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpIHtcbiAgLy8gcHJpdmF0ZUtleUltcG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSk7XG4gIGlmIChwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcblxuLyoqXG4gKiBOZWdhdGUgYSBwcml2YXRlS2V5IGJ5IHN1YnRyYWN0aW5nIGl0IGZyb20gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleU5lZ2F0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlOZWdhdGUgPSBmdW5jdGlvbiBwcml2YXRlS2V5TmVnYXRlKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgcHJpdmF0ZUtleSAobW9kdWxvIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50KS5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleU1vZEludmVyc2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlNb2RJbnZlcnNlKHByaXZhdGVLZXkpIHtcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5wcml2YXRlS2V5TW9kSW52ZXJzZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtBZGQocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2Vhay5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtNdWwocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZUtleS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q3JlYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gcHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHVibGljS2V5VHdlYWtBZGQocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsgdmFsdWVcbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBnaXZlbiBwdWJsaWNLZXlzIHRvZ2V0aGVyLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb21iaW5lXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIHB1YmxpY0tleUNvbWJpbmUocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBwdWJsaWNLZXlzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gIH0pO1xuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShrZXlzLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVOb3JtYWxpemUgPSBmdW5jdGlvbiBzaWduYXR1cmVOb3JtYWxpemUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gREVSIGZvcm1hdC5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlRXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVFeHBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAoZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVJbXBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSkge1xuICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHRoYXQgc2lnbmF0dXJlIGlzIGdyZWF0ZXIgdGhhbiAwXG4gIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgaWYgKHNpZ09iaiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxdjMuc2lnbmF0dXJlSW1wb3J0KHNpZ09iaik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgc2lnbk9wdGlvbnMgPSB2b2lkIDA7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBzaWduT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbi5kYXRhIGxlbmd0aFxuICAgICAgaWYgKG9wdGlvbnMuZGF0YS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgIH1cblxuICAgICAgc2lnbk9wdGlvbnMuZGF0YSA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2VmbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgLy8gIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckFsZ28gPSBhbGdvICE9IG51bGwgPyBCdWZmZXIuZnJvbShhbGdvKSA6IG51bGw7XG4gICAgICAgIHZhciBidWZmZXJEYXRhID0gZGF0YSAhPSBudWxsID8gQnVmZmVyLmZyb20oZGF0YSkgOiBudWxsO1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbSgnJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMubm9uY2VmbihCdWZmZXIuZnJvbShtZXNzYWdlKSwgQnVmZmVyLmZyb20ocHJpdmF0ZUtleSksIGJ1ZmZlckFsZ28sIGJ1ZmZlckRhdGEsIGF0dGVtcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuc2lnbmF0dXJlKSxcbiAgICByZWNvdmVyeTogc2lnLnJlY2lkXG4gIH07XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciB2ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHZlcmlmeSBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgcHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcmVjb3ZlciA9IGZ1bmN0aW9uIHJlY292ZXIobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgcmVjb3ZlciBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCBhcHBsaWVkIHNoYTI1NiB0byBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gKiBAbWV0aG9kIGVjZGhcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoID0gZnVuY3Rpb24gZWNkaChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB7fSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgcmV0dXJuIHB1YmxpYyBrZXkgYXMgcmVzdWx0XG4gKiBAbWV0aG9kIGVjZGhVbnNhZmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGhVbnNhZmUgPSBmdW5jdGlvbiBlY2RoVW5zYWZlKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAvLyBlY2RoVW5zYWZlIG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsaWQgcHJpdmF0ZUtleSBsZW5ndGhcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLmVjZGhVbnNhZmUoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByaXZhdGVLZXlWZXJpZnk6IHByaXZhdGVLZXlWZXJpZnksXG4gIHByaXZhdGVLZXlFeHBvcnQ6IHByaXZhdGVLZXlFeHBvcnQsXG4gIHByaXZhdGVLZXlJbXBvcnQ6IHByaXZhdGVLZXlJbXBvcnQsXG4gIHByaXZhdGVLZXlOZWdhdGU6IHByaXZhdGVLZXlOZWdhdGUsXG4gIHByaXZhdGVLZXlNb2RJbnZlcnNlOiBwcml2YXRlS2V5TW9kSW52ZXJzZSxcbiAgcHJpdmF0ZUtleVR3ZWFrQWRkOiBwcml2YXRlS2V5VHdlYWtBZGQsXG4gIHByaXZhdGVLZXlUd2Vha011bDogcHJpdmF0ZUtleVR3ZWFrTXVsLFxuXG4gIHB1YmxpY0tleUNyZWF0ZTogcHVibGljS2V5Q3JlYXRlLFxuICBwdWJsaWNLZXlDb252ZXJ0OiBwdWJsaWNLZXlDb252ZXJ0LFxuICBwdWJsaWNLZXlWZXJpZnk6IHB1YmxpY0tleVZlcmlmeSxcbiAgcHVibGljS2V5VHdlYWtBZGQ6IHB1YmxpY0tleVR3ZWFrQWRkLFxuICBwdWJsaWNLZXlUd2Vha011bDogcHVibGljS2V5VHdlYWtNdWwsXG4gIHB1YmxpY0tleUNvbWJpbmU6IHB1YmxpY0tleUNvbWJpbmUsXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplOiBzaWduYXR1cmVOb3JtYWxpemUsXG4gIHNpZ25hdHVyZUV4cG9ydDogc2lnbmF0dXJlRXhwb3J0LFxuICBzaWduYXR1cmVJbXBvcnQ6IHNpZ25hdHVyZUltcG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0TGF4OiBzaWduYXR1cmVJbXBvcnRMYXgsXG5cbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHJlY292ZXI6IHJlY292ZXIsXG5cbiAgZWNkaDogZWNkaCxcbiAgZWNkaFVuc2FmZTogZWNkaFVuc2FmZVxufTsiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwicmVxdWlyZSIsInNlY3AyNTZrMXYzIiwiZGVyIiwicHJpdmF0ZUtleVZlcmlmeSIsInByaXZhdGVLZXkiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwiZnJvbSIsInByaXZhdGVLZXlFeHBvcnQiLCJjb21wcmVzc2VkIiwiUmFuZ2VFcnJvciIsInB1YmxpY0tleSIsInByaXZhdGVLZXlJbXBvcnQiLCJFcnJvciIsInByaXZhdGVLZXlOZWdhdGUiLCJCdWZmZXIiLCJwcml2YXRlS2V5TW9kSW52ZXJzZSIsInByaXZhdGVLZXlUd2Vha0FkZCIsInR3ZWFrIiwicHJpdmF0ZUtleVR3ZWFrTXVsIiwicHVibGljS2V5Q3JlYXRlIiwicHVibGljS2V5Q29udmVydCIsInB1YmxpY0tleVZlcmlmeSIsInB1YmxpY0tleVR3ZWFrQWRkIiwicHVibGljS2V5VHdlYWtNdWwiLCJwdWJsaWNLZXlDb21iaW5lIiwicHVibGljS2V5cyIsImtleXMiLCJmb3JFYWNoIiwicHVzaCIsInNpZ25hdHVyZU5vcm1hbGl6ZSIsInNpZ25hdHVyZSIsInNpZ25hdHVyZUV4cG9ydCIsInNpZ25hdHVyZUltcG9ydCIsInNpZ25hdHVyZUltcG9ydExheCIsInNpZ09iaiIsInNpZ24iLCJtZXNzYWdlIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsInNpZ25PcHRpb25zIiwiZGF0YSIsIm5vbmNlZm4iLCJhbGdvIiwiYXR0ZW1wdCIsImJ1ZmZlckFsZ28iLCJidWZmZXJEYXRhIiwiYnVmZmVyIiwic2lnIiwiZWNkc2FTaWduIiwicmVjb3ZlcnkiLCJyZWNpZCIsInZlcmlmeSIsImVjZHNhVmVyaWZ5IiwicmVjb3ZlciIsImVjZHNhUmVjb3ZlciIsImVjZGgiLCJlY2RoVW5zYWZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/der.js":
/*!****************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/secp256k1-lib/der.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nvar EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([\n    // begin\n    0x30,\n    0x81,\n    0xd3,\n    0x02,\n    0x01,\n    0x01,\n    0x04,\n    0x20,\n    // private key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    // middle\n    0xa0,\n    0x81,\n    0x85,\n    0x30,\n    0x81,\n    0x82,\n    0x02,\n    0x01,\n    0x01,\n    0x30,\n    0x2c,\n    0x06,\n    0x07,\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x01,\n    0x01,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xff,\n    0xff,\n    0xfc,\n    0x2f,\n    0x30,\n    0x06,\n    0x04,\n    0x01,\n    0x00,\n    0x04,\n    0x01,\n    0x07,\n    0x04,\n    0x21,\n    0x02,\n    0x79,\n    0xbe,\n    0x66,\n    0x7e,\n    0xf9,\n    0xdc,\n    0xbb,\n    0xac,\n    0x55,\n    0xa0,\n    0x62,\n    0x95,\n    0xce,\n    0x87,\n    0x0b,\n    0x07,\n    0x02,\n    0x9b,\n    0xfc,\n    0xdb,\n    0x2d,\n    0xce,\n    0x28,\n    0xd9,\n    0x59,\n    0xf2,\n    0x81,\n    0x5b,\n    0x16,\n    0xf8,\n    0x17,\n    0x98,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xba,\n    0xae,\n    0xdc,\n    0xe6,\n    0xaf,\n    0x48,\n    0xa0,\n    0x3b,\n    0xbf,\n    0xd2,\n    0x5e,\n    0x8c,\n    0xd0,\n    0x36,\n    0x41,\n    0x41,\n    0x02,\n    0x01,\n    0x01,\n    0xa1,\n    0x24,\n    0x03,\n    0x22,\n    0x00,\n    // public key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n]);\nvar EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([\n    // begin\n    0x30,\n    0x82,\n    0x01,\n    0x13,\n    0x02,\n    0x01,\n    0x01,\n    0x04,\n    0x20,\n    // private key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    // middle\n    0xa0,\n    0x81,\n    0xa5,\n    0x30,\n    0x81,\n    0xa2,\n    0x02,\n    0x01,\n    0x01,\n    0x30,\n    0x2c,\n    0x06,\n    0x07,\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x01,\n    0x01,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xff,\n    0xff,\n    0xfc,\n    0x2f,\n    0x30,\n    0x06,\n    0x04,\n    0x01,\n    0x00,\n    0x04,\n    0x01,\n    0x07,\n    0x04,\n    0x41,\n    0x04,\n    0x79,\n    0xbe,\n    0x66,\n    0x7e,\n    0xf9,\n    0xdc,\n    0xbb,\n    0xac,\n    0x55,\n    0xa0,\n    0x62,\n    0x95,\n    0xce,\n    0x87,\n    0x0b,\n    0x07,\n    0x02,\n    0x9b,\n    0xfc,\n    0xdb,\n    0x2d,\n    0xce,\n    0x28,\n    0xd9,\n    0x59,\n    0xf2,\n    0x81,\n    0x5b,\n    0x16,\n    0xf8,\n    0x17,\n    0x98,\n    0x48,\n    0x3a,\n    0xda,\n    0x77,\n    0x26,\n    0xa3,\n    0xc4,\n    0x65,\n    0x5d,\n    0xa4,\n    0xfb,\n    0xfc,\n    0x0e,\n    0x11,\n    0x08,\n    0xa8,\n    0xfd,\n    0x17,\n    0xb4,\n    0x48,\n    0xa6,\n    0x85,\n    0x54,\n    0x19,\n    0x9c,\n    0x47,\n    0xd0,\n    0x8f,\n    0xfb,\n    0x10,\n    0xd4,\n    0xb8,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xba,\n    0xae,\n    0xdc,\n    0xe6,\n    0xaf,\n    0x48,\n    0xa0,\n    0x3b,\n    0xbf,\n    0xd2,\n    0x5e,\n    0x8c,\n    0xd0,\n    0x36,\n    0x41,\n    0x41,\n    0x02,\n    0x01,\n    0x01,\n    0xa1,\n    0x44,\n    0x03,\n    0x42,\n    0x00,\n    // public key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n]);\nexports.privateKeyExport = function(privateKey, publicKey, compressed) {\n    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);\n    privateKey.copy(result, compressed ? 8 : 9);\n    publicKey.copy(result, compressed ? 181 : 214);\n    return result;\n};\nexports.privateKeyImport = function(privateKey) {\n    var length = privateKey.length;\n    // sequence header\n    var index = 0;\n    if (length < index + 1 || privateKey[index] !== 0x30) return null;\n    index += 1;\n    // sequence length constructor\n    if (length < index + 1 || !(privateKey[index] & 0x80)) return null;\n    var lenb = privateKey[index] & 0x7f;\n    index += 1;\n    if (lenb < 1 || lenb > 2) return null;\n    if (length < index + lenb) return null;\n    // sequence length\n    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);\n    index += lenb;\n    if (length < index + len) return null;\n    // sequence element 0: version number (=1)\n    if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {\n        return null;\n    }\n    index += 3;\n    // sequence element 1: octet string, up to 32 bytes\n    if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {\n        return null;\n    }\n    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);\n};\nexports.signatureImportLax = function(signature) {\n    var r = Buffer.alloc(32, 0);\n    var s = Buffer.alloc(32, 0);\n    var length = signature.length;\n    var index = 0;\n    // sequence tag byte\n    if (signature[index++] !== 0x30) {\n        return null;\n    }\n    // sequence length byte\n    var lenbyte = signature[index++];\n    if (lenbyte & 0x80) {\n        index += lenbyte - 0x80;\n        if (index > length) {\n            return null;\n        }\n    }\n    // sequence tag byte for r\n    if (signature[index++] !== 0x02) {\n        return null;\n    }\n    // length for r\n    var rlen = signature[index++];\n    if (rlen & 0x80) {\n        lenbyte = rlen - 0x80;\n        if (index + lenbyte > length) {\n            return null;\n        }\n        for(; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1){}\n        for(rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1){\n            rlen = (rlen << 8) + signature[index];\n        }\n    }\n    if (rlen > length - index) {\n        return null;\n    }\n    var rindex = index;\n    index += rlen;\n    // sequence tag byte for s\n    if (signature[index++] !== 0x02) {\n        return null;\n    }\n    // length for s\n    var slen = signature[index++];\n    if (slen & 0x80) {\n        lenbyte = slen - 0x80;\n        if (index + lenbyte > length) {\n            return null;\n        }\n        for(; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1){}\n        for(slen = 0; lenbyte > 0; index += 1, lenbyte -= 1){\n            slen = (slen << 8) + signature[index];\n        }\n    }\n    if (slen > length - index) {\n        return null;\n    }\n    var sindex = index;\n    index += slen;\n    // ignore leading zeros in r\n    for(; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1){}\n    // copy r value\n    if (rlen > 32) {\n        return null;\n    }\n    var rvalue = signature.slice(rindex, rindex + rlen);\n    rvalue.copy(r, 32 - rvalue.length);\n    // ignore leading zeros in s\n    for(; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1){}\n    // copy s value\n    if (slen > 32) {\n        return null;\n    }\n    var svalue = signature.slice(sindex, sindex + slen);\n    svalue.copy(s, 32 - svalue.length);\n    return {\n        r: r,\n        s: s\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYiwwQ0FBMEM7QUFDMUMscUVBQXFFO0FBRXJFLElBQUlBLG1DQUFtQ0MsT0FBT0MsSUFBSSxDQUFDO0lBQ25ELFFBQVE7SUFDUjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFDLGNBQWM7SUFDZDtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFMLFNBQVM7SUFDVDtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDeDBCLGFBQWE7SUFDYjtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBSztBQUVyTSxJQUFJQyxxQ0FBcUNGLE9BQU9DLElBQUksQ0FBQztJQUNyRCxRQUFRO0lBQ1I7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQ2hELGNBQWM7SUFDZDtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQzFMLFNBQVM7SUFDVDtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQ3hnQyxhQUFhO0lBQ2I7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtDQUFLO0FBRXJZRSx3QkFBd0IsR0FBRyxTQUFVRSxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsVUFBVTtJQUNwRSxJQUFJQyxTQUFTUixPQUFPQyxJQUFJLENBQUNNLGFBQWFSLG1DQUFtQ0c7SUFDekVHLFdBQVdJLElBQUksQ0FBQ0QsUUFBUUQsYUFBYSxJQUFJO0lBQ3pDRCxVQUFVRyxJQUFJLENBQUNELFFBQVFELGFBQWEsTUFBTTtJQUMxQyxPQUFPQztBQUNUO0FBRUFMLHdCQUF3QixHQUFHLFNBQVVFLFVBQVU7SUFDN0MsSUFBSU0sU0FBU04sV0FBV00sTUFBTTtJQUU5QixrQkFBa0I7SUFDbEIsSUFBSUMsUUFBUTtJQUNaLElBQUlELFNBQVNDLFFBQVEsS0FBS1AsVUFBVSxDQUFDTyxNQUFNLEtBQUssTUFBTSxPQUFPO0lBQzdEQSxTQUFTO0lBRVQsOEJBQThCO0lBQzlCLElBQUlELFNBQVNDLFFBQVEsS0FBSyxDQUFFUCxDQUFBQSxVQUFVLENBQUNPLE1BQU0sR0FBRyxJQUFHLEdBQUksT0FBTztJQUU5RCxJQUFJQyxPQUFPUixVQUFVLENBQUNPLE1BQU0sR0FBRztJQUMvQkEsU0FBUztJQUNULElBQUlDLE9BQU8sS0FBS0EsT0FBTyxHQUFHLE9BQU87SUFDakMsSUFBSUYsU0FBU0MsUUFBUUMsTUFBTSxPQUFPO0lBRWxDLGtCQUFrQjtJQUNsQixJQUFJQyxNQUFNVCxVQUFVLENBQUNPLFFBQVFDLE9BQU8sRUFBRSxHQUFJQSxDQUFBQSxPQUFPLElBQUlSLFVBQVUsQ0FBQ08sUUFBUUMsT0FBTyxFQUFFLElBQUksSUFBSTtJQUN6RkQsU0FBU0M7SUFDVCxJQUFJRixTQUFTQyxRQUFRRSxLQUFLLE9BQU87SUFFakMsMENBQTBDO0lBQzFDLElBQUlILFNBQVNDLFFBQVEsS0FBS1AsVUFBVSxDQUFDTyxNQUFNLEtBQUssUUFBUVAsVUFBVSxDQUFDTyxRQUFRLEVBQUUsS0FBSyxRQUFRUCxVQUFVLENBQUNPLFFBQVEsRUFBRSxLQUFLLE1BQU07UUFDeEgsT0FBTztJQUNUO0lBQ0FBLFNBQVM7SUFFVCxtREFBbUQ7SUFDbkQsSUFBSUQsU0FBU0MsUUFBUSxLQUFLUCxVQUFVLENBQUNPLE1BQU0sS0FBSyxRQUFRUCxVQUFVLENBQUNPLFFBQVEsRUFBRSxHQUFHLFFBQVFELFNBQVNDLFFBQVEsSUFBSVAsVUFBVSxDQUFDTyxRQUFRLEVBQUUsRUFBRTtRQUNsSSxPQUFPO0lBQ1Q7SUFFQSxPQUFPUCxXQUFXVSxLQUFLLENBQUNILFFBQVEsR0FBR0EsUUFBUSxJQUFJUCxVQUFVLENBQUNPLFFBQVEsRUFBRTtBQUN0RTtBQUVBVCwwQkFBMEIsR0FBRyxTQUFVYyxTQUFTO0lBQzlDLElBQUlDLElBQUlsQixPQUFPbUIsS0FBSyxDQUFDLElBQUk7SUFDekIsSUFBSUMsSUFBSXBCLE9BQU9tQixLQUFLLENBQUMsSUFBSTtJQUV6QixJQUFJUixTQUFTTSxVQUFVTixNQUFNO0lBQzdCLElBQUlDLFFBQVE7SUFFWixvQkFBb0I7SUFDcEIsSUFBSUssU0FBUyxDQUFDTCxRQUFRLEtBQUssTUFBTTtRQUMvQixPQUFPO0lBQ1Q7SUFFQSx1QkFBdUI7SUFDdkIsSUFBSVMsVUFBVUosU0FBUyxDQUFDTCxRQUFRO0lBQ2hDLElBQUlTLFVBQVUsTUFBTTtRQUNsQlQsU0FBU1MsVUFBVTtRQUNuQixJQUFJVCxRQUFRRCxRQUFRO1lBQ2xCLE9BQU87UUFDVDtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLElBQUlNLFNBQVMsQ0FBQ0wsUUFBUSxLQUFLLE1BQU07UUFDL0IsT0FBTztJQUNUO0lBRUEsZUFBZTtJQUNmLElBQUlVLE9BQU9MLFNBQVMsQ0FBQ0wsUUFBUTtJQUM3QixJQUFJVSxPQUFPLE1BQU07UUFDZkQsVUFBVUMsT0FBTztRQUNqQixJQUFJVixRQUFRUyxVQUFVVixRQUFRO1lBQzVCLE9BQU87UUFDVDtRQUNBLE1BQU9VLFVBQVUsS0FBS0osU0FBUyxDQUFDTCxNQUFNLEtBQUssTUFBTUEsU0FBUyxHQUFHUyxXQUFXLEVBQUcsQ0FBQztRQUM1RSxJQUFLQyxPQUFPLEdBQUdELFVBQVUsR0FBR1QsU0FBUyxHQUFHUyxXQUFXLEVBQUc7WUFDcERDLE9BQU8sQ0FBQ0EsUUFBUSxLQUFLTCxTQUFTLENBQUNMLE1BQU07UUFDdkM7SUFDRjtJQUNBLElBQUlVLE9BQU9YLFNBQVNDLE9BQU87UUFDekIsT0FBTztJQUNUO0lBQ0EsSUFBSVcsU0FBU1g7SUFDYkEsU0FBU1U7SUFFVCwwQkFBMEI7SUFDMUIsSUFBSUwsU0FBUyxDQUFDTCxRQUFRLEtBQUssTUFBTTtRQUMvQixPQUFPO0lBQ1Q7SUFFQSxlQUFlO0lBQ2YsSUFBSVksT0FBT1AsU0FBUyxDQUFDTCxRQUFRO0lBQzdCLElBQUlZLE9BQU8sTUFBTTtRQUNmSCxVQUFVRyxPQUFPO1FBQ2pCLElBQUlaLFFBQVFTLFVBQVVWLFFBQVE7WUFDNUIsT0FBTztRQUNUO1FBQ0EsTUFBT1UsVUFBVSxLQUFLSixTQUFTLENBQUNMLE1BQU0sS0FBSyxNQUFNQSxTQUFTLEdBQUdTLFdBQVcsRUFBRyxDQUFDO1FBQzVFLElBQUtHLE9BQU8sR0FBR0gsVUFBVSxHQUFHVCxTQUFTLEdBQUdTLFdBQVcsRUFBRztZQUNwREcsT0FBTyxDQUFDQSxRQUFRLEtBQUtQLFNBQVMsQ0FBQ0wsTUFBTTtRQUN2QztJQUNGO0lBQ0EsSUFBSVksT0FBT2IsU0FBU0MsT0FBTztRQUN6QixPQUFPO0lBQ1Q7SUFDQSxJQUFJYSxTQUFTYjtJQUNiQSxTQUFTWTtJQUVULDRCQUE0QjtJQUM1QixNQUFPRixPQUFPLEtBQUtMLFNBQVMsQ0FBQ00sT0FBTyxLQUFLLE1BQU1ELFFBQVEsR0FBR0MsVUFBVSxFQUFHLENBQUM7SUFDeEUsZUFBZTtJQUNmLElBQUlELE9BQU8sSUFBSTtRQUNiLE9BQU87SUFDVDtJQUNBLElBQUlJLFNBQVNULFVBQVVGLEtBQUssQ0FBQ1EsUUFBUUEsU0FBU0Q7SUFDOUNJLE9BQU9qQixJQUFJLENBQUNTLEdBQUcsS0FBS1EsT0FBT2YsTUFBTTtJQUVqQyw0QkFBNEI7SUFDNUIsTUFBT2EsT0FBTyxLQUFLUCxTQUFTLENBQUNRLE9BQU8sS0FBSyxNQUFNRCxRQUFRLEdBQUdDLFVBQVUsRUFBRyxDQUFDO0lBQ3hFLGVBQWU7SUFDZixJQUFJRCxPQUFPLElBQUk7UUFDYixPQUFPO0lBQ1Q7SUFDQSxJQUFJRyxTQUFTVixVQUFVRixLQUFLLENBQUNVLFFBQVFBLFNBQVNEO0lBQzlDRyxPQUFPbEIsSUFBSSxDQUFDVyxHQUFHLEtBQUtPLE9BQU9oQixNQUFNO0lBRWpDLE9BQU87UUFBRU8sR0FBR0E7UUFBR0UsR0FBR0E7SUFBRTtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZWZyb250Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvZGVyLmpzPzY5NDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4MjEsIDB4MDIsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHhhNSwgMHgzMCwgMHg4MSwgMHhhMiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHg0MSwgMHgwNCwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHg0OCwgMHgzYSwgMHhkYSwgMHg3NywgMHgyNiwgMHhhMywgMHhjNCwgMHg2NSwgMHg1ZCwgMHhhNCwgMHhmYiwgMHhmYywgMHgwZSwgMHgxMSwgMHgwOCwgMHhhOCwgMHhmZCwgMHgxNywgMHhiNCwgMHg0OCwgMHhhNiwgMHg4NSwgMHg1NCwgMHgxOSwgMHg5YywgMHg0NywgMHhkMCwgMHg4ZiwgMHhmYiwgMHgxMCwgMHhkNCwgMHhiOCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHg0NCwgMHgwMywgMHg0MiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCk7XG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgbGVuZ3RoID0gcHJpdmF0ZUtleS5sZW5ndGg7XG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVybiBudWxsO1xuICBpbmRleCArPSAxO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBjb25zdHJ1Y3RvclxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gIGluZGV4ICs9IDE7XG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICBpbmRleCArPSBsZW5iO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fCBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpbmRleCArPSAzO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHwgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5cbiAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChsZW5ieXRlICYgMHg4MCkge1xuICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gcmxlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gcmxlbjtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChzbGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoc2xlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBzbGVuO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ25hdHVyZVtyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gIGZvciAoOyBzbGVuID4gMCAmJiBzaWduYXR1cmVbc2luZGV4XSA9PT0gMHgwMDsgc2xlbiAtPSAxLCBzaW5kZXggKz0gMSkge31cbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTsiXSwibmFtZXMiOlsiRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQiLCJCdWZmZXIiLCJmcm9tIiwiRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCIsImV4cG9ydHMiLCJwcml2YXRlS2V5RXhwb3J0IiwicHJpdmF0ZUtleSIsInB1YmxpY0tleSIsImNvbXByZXNzZWQiLCJyZXN1bHQiLCJjb3B5IiwicHJpdmF0ZUtleUltcG9ydCIsImxlbmd0aCIsImluZGV4IiwibGVuYiIsImxlbiIsInNsaWNlIiwic2lnbmF0dXJlSW1wb3J0TGF4Iiwic2lnbmF0dXJlIiwiciIsImFsbG9jIiwicyIsImxlbmJ5dGUiLCJybGVuIiwicmluZGV4Iiwic2xlbiIsInNpbmRleCIsInJ2YWx1ZSIsInN2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/der.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/ethereumjs-util/dist/secp256k1-lib/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\").ec);\nvar ec = new EC(\"secp256k1\");\nvar ecparams = ec.curve;\nexports.privateKeyExport = function(privateKey, compressed) {\n    var d = new BN(privateKey);\n    if (d.ucmp(ecparams.n) >= 0) {\n        throw new Error(\"couldn't export to DER format\");\n    }\n    var point = ec.g.mul(d);\n    return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function(privateKey) {\n    var bn = new BN(privateKey);\n    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n        throw new Error(\"private key range is invalid\");\n    }\n    return bn.invm(ecparams.n).toArrayLike(Buffer, \"be\", 32);\n};\nexports.signatureImport = function(sigObj) {\n    var r = new BN(sigObj.r);\n    if (r.ucmp(ecparams.n) >= 0) {\n        r = new BN(0);\n    }\n    var s = new BN(sigObj.s);\n    if (s.ucmp(ecparams.n) >= 0) {\n        s = new BN(0);\n    }\n    return Buffer.concat([\n        r.toArrayLike(Buffer, \"be\", 32),\n        s.toArrayLike(Buffer, \"be\", 32)\n    ]);\n};\nexports.ecdhUnsafe = function(publicKey, privateKey, compressed) {\n    var point = ec.keyFromPublic(publicKey);\n    var scalar = new BN(privateKey);\n    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n        throw new Error(\"scalar was invalid (zero or overflow)\");\n    }\n    var shared = point.pub.mul(scalar);\n    return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function toPublicKey(x, y, compressed) {\n    var publicKey = void 0;\n    if (compressed) {\n        publicKey = Buffer.alloc(33);\n        publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n        x.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 1);\n    } else {\n        publicKey = Buffer.alloc(65);\n        publicKey[0] = 0x04;\n        x.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 1);\n        y.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 33);\n    }\n    return publicKey;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDBDQUEwQztBQUMxQyxxRUFBcUU7QUFFckUsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUM7QUFDakIsSUFBSUMsS0FBS0QseUZBQXNCO0FBRS9CLElBQUlFLEtBQUssSUFBSUQsR0FBRztBQUNoQixJQUFJRSxXQUFXRCxHQUFHRSxLQUFLO0FBRXZCQyx3QkFBd0IsR0FBRyxTQUFVRSxVQUFVLEVBQUVDLFVBQVU7SUFDekQsSUFBSUMsSUFBSSxJQUFJVixHQUFHUTtJQUNmLElBQUlFLEVBQUVDLElBQUksQ0FBQ1AsU0FBU1EsQ0FBQyxLQUFLLEdBQUc7UUFDM0IsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsSUFBSUMsUUFBUVgsR0FBR1ksQ0FBQyxDQUFDQyxHQUFHLENBQUNOO0lBQ3JCLE9BQU9PLFlBQVlILE1BQU1JLElBQUksSUFBSUosTUFBTUssSUFBSSxJQUFJVjtBQUNqRDtBQUVBSCw0QkFBNEIsR0FBRyxTQUFVRSxVQUFVO0lBQ2pELElBQUlhLEtBQUssSUFBSXJCLEdBQUdRO0lBQ2hCLElBQUlhLEdBQUdWLElBQUksQ0FBQ1AsU0FBU1EsQ0FBQyxLQUFLLEtBQUtTLEdBQUdDLE1BQU0sSUFBSTtRQUMzQyxNQUFNLElBQUlULE1BQU07SUFDbEI7SUFFQSxPQUFPUSxHQUFHRSxJQUFJLENBQUNuQixTQUFTUSxDQUFDLEVBQUVZLFdBQVcsQ0FBQ0MsUUFBUSxNQUFNO0FBQ3ZEO0FBRUFuQix1QkFBdUIsR0FBRyxTQUFVcUIsTUFBTTtJQUN4QyxJQUFJQyxJQUFJLElBQUk1QixHQUFHMkIsT0FBT0MsQ0FBQztJQUN2QixJQUFJQSxFQUFFakIsSUFBSSxDQUFDUCxTQUFTUSxDQUFDLEtBQUssR0FBRztRQUMzQmdCLElBQUksSUFBSTVCLEdBQUc7SUFDYjtJQUVBLElBQUk2QixJQUFJLElBQUk3QixHQUFHMkIsT0FBT0UsQ0FBQztJQUN2QixJQUFJQSxFQUFFbEIsSUFBSSxDQUFDUCxTQUFTUSxDQUFDLEtBQUssR0FBRztRQUMzQmlCLElBQUksSUFBSTdCLEdBQUc7SUFDYjtJQUVBLE9BQU95QixPQUFPSyxNQUFNLENBQUM7UUFBQ0YsRUFBRUosV0FBVyxDQUFDQyxRQUFRLE1BQU07UUFBS0ksRUFBRUwsV0FBVyxDQUFDQyxRQUFRLE1BQU07S0FBSTtBQUN6RjtBQUVBbkIsa0JBQWtCLEdBQUcsU0FBVTBCLFNBQVMsRUFBRXhCLFVBQVUsRUFBRUMsVUFBVTtJQUM5RCxJQUFJSyxRQUFRWCxHQUFHOEIsYUFBYSxDQUFDRDtJQUU3QixJQUFJRSxTQUFTLElBQUlsQyxHQUFHUTtJQUNwQixJQUFJMEIsT0FBT3ZCLElBQUksQ0FBQ1AsU0FBU1EsQ0FBQyxLQUFLLEtBQUtzQixPQUFPWixNQUFNLElBQUk7UUFDbkQsTUFBTSxJQUFJVCxNQUFNO0lBQ2xCO0lBRUEsSUFBSXNCLFNBQVNyQixNQUFNc0IsR0FBRyxDQUFDcEIsR0FBRyxDQUFDa0I7SUFDM0IsT0FBT2pCLFlBQVlrQixPQUFPakIsSUFBSSxJQUFJaUIsT0FBT2hCLElBQUksSUFBSVY7QUFDbkQ7QUFFQSxJQUFJUSxjQUFjLFNBQVNBLFlBQVlvQixDQUFDLEVBQUVDLENBQUMsRUFBRTdCLFVBQVU7SUFDckQsSUFBSXVCLFlBQVksS0FBSztJQUVyQixJQUFJdkIsWUFBWTtRQUNkdUIsWUFBWVAsT0FBT2MsS0FBSyxDQUFDO1FBQ3pCUCxTQUFTLENBQUMsRUFBRSxHQUFHTSxFQUFFRSxLQUFLLEtBQUssT0FBTztRQUNsQ0gsRUFBRWIsV0FBVyxDQUFDQyxRQUFRLE1BQU0sSUFBSWdCLElBQUksQ0FBQ1QsV0FBVztJQUNsRCxPQUFPO1FBQ0xBLFlBQVlQLE9BQU9jLEtBQUssQ0FBQztRQUN6QlAsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUNmSyxFQUFFYixXQUFXLENBQUNDLFFBQVEsTUFBTSxJQUFJZ0IsSUFBSSxDQUFDVCxXQUFXO1FBQ2hETSxFQUFFZCxXQUFXLENBQUNDLFFBQVEsTUFBTSxJQUFJZ0IsSUFBSSxDQUFDVCxXQUFXO0lBQ2xEO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZWZyb250Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvaW5kZXguanM/NDM1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkblxcJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXQnKTtcbiAgfVxuXG4gIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICByID0gbmV3IEJOKDApO1xuICB9XG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICBzID0gbmV3IEJOKDApO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICB9XG5cbiAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gdG9QdWJsaWNLZXkoeCwgeSwgY29tcHJlc3NlZCkge1xuICB2YXIgcHVibGljS2V5ID0gdm9pZCAwO1xuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07Il0sIm5hbWVzIjpbIkJOIiwicmVxdWlyZSIsIkVDIiwiZWMiLCJlY3BhcmFtcyIsImN1cnZlIiwiZXhwb3J0cyIsInByaXZhdGVLZXlFeHBvcnQiLCJwcml2YXRlS2V5IiwiY29tcHJlc3NlZCIsImQiLCJ1Y21wIiwibiIsIkVycm9yIiwicG9pbnQiLCJnIiwibXVsIiwidG9QdWJsaWNLZXkiLCJnZXRYIiwiZ2V0WSIsInByaXZhdGVLZXlNb2RJbnZlcnNlIiwiYm4iLCJpc1plcm8iLCJpbnZtIiwidG9BcnJheUxpa2UiLCJCdWZmZXIiLCJzaWduYXR1cmVJbXBvcnQiLCJzaWdPYmoiLCJyIiwicyIsImNvbmNhdCIsImVjZGhVbnNhZmUiLCJwdWJsaWNLZXkiLCJrZXlGcm9tUHVibGljIiwic2NhbGFyIiwic2hhcmVkIiwicHViIiwieCIsInkiLCJhbGxvYyIsImlzT2RkIiwiY29weSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-util/dist/secp256k1-lib/index.js\n");

/***/ })

};
;