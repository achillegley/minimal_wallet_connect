"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ethereumjs-abi";
exports.ids = ["vendor-chunks/ethereumjs-abi"];
exports.modules = {

/***/ "(ssr)/./node_modules/ethereumjs-abi/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ethereumjs-abi/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./lib/index.js */ \"(ssr)/./node_modules/ethereumjs-abi/lib/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBQSw4R0FBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9pbmRleC5qcz9jNWNhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvaW5kZXguanMnKVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/ethereumjs-abi/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-useless-escape */ \nconst utils = __webpack_require__(/*! ethereumjs-util */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js\");\nconst BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar ABI = function() {};\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName(name) {\n    if (name.startsWith(\"int[\")) {\n        return \"int256\" + name.slice(3);\n    } else if (name === \"int\") {\n        return \"int256\";\n    } else if (name.startsWith(\"uint[\")) {\n        return \"uint256\" + name.slice(4);\n    } else if (name === \"uint\") {\n        return \"uint256\";\n    } else if (name.startsWith(\"fixed[\")) {\n        return \"fixed128x128\" + name.slice(5);\n    } else if (name === \"fixed\") {\n        return \"fixed128x128\";\n    } else if (name.startsWith(\"ufixed[\")) {\n        return \"ufixed128x128\" + name.slice(6);\n    } else if (name === \"ufixed\") {\n        return \"ufixed128x128\";\n    }\n    return name;\n}\nABI.eventID = function(name, types) {\n    // FIXME: use node.js util.format?\n    var sig = name + \"(\" + types.map(elementaryName).join(\",\") + \")\";\n    return utils.keccak256(Buffer.from(sig));\n};\nABI.methodID = function(name, types) {\n    return ABI.eventID(name, types).slice(0, 4);\n};\n// Parse N from type<N>\nfunction parseTypeN(type) {\n    return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n}\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM(type) {\n    var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n    return [\n        parseInt(tmp[1], 10),\n        parseInt(tmp[2], 10)\n    ];\n}\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray(type) {\n    var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n    if (tmp) {\n        return tmp[2] === \"\" ? \"dynamic\" : parseInt(tmp[2], 10);\n    }\n    return null;\n}\nfunction parseNumber(arg) {\n    var type = typeof arg;\n    if (type === \"string\") {\n        if (utils.isHexPrefixed(arg)) {\n            return new BN(utils.stripHexPrefix(arg), 16);\n        } else {\n            return new BN(arg, 10);\n        }\n    } else if (type === \"number\") {\n        return new BN(arg);\n    } else if (arg.toArray) {\n        // assume this is a BN for the moment, replace with BN.isBN soon\n        return arg;\n    } else {\n        throw new Error(\"Argument is not a number\");\n    }\n}\n// someMethod(bytes,uint)\n// someMethod(bytes,uint):(boolean)\nfunction parseSignature(sig) {\n    var tmp = /^(\\w+)\\((.*)\\)$/.exec(sig);\n    if (tmp.length !== 3) {\n        throw new Error(\"Invalid method signature\");\n    }\n    var args = /^(.+)\\):\\((.+)$/.exec(tmp[2]);\n    if (args !== null && args.length === 3) {\n        return {\n            method: tmp[1],\n            args: args[1].split(\",\"),\n            retargs: args[2].split(\",\")\n        };\n    } else {\n        var params = tmp[2].split(\",\");\n        if (params.length === 1 && params[0] === \"\") {\n            // Special-case (possibly naive) fixup for functions that take no arguments.\n            // TODO: special cases are always bad, but this makes the function return\n            // match what the calling functions expect\n            params = [];\n        }\n        return {\n            method: tmp[1],\n            args: params\n        };\n    }\n}\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle(type, arg) {\n    var size, num, ret, i;\n    if (type === \"address\") {\n        return encodeSingle(\"uint160\", parseNumber(arg));\n    } else if (type === \"bool\") {\n        return encodeSingle(\"uint8\", arg ? 1 : 0);\n    } else if (type === \"string\") {\n        return encodeSingle(\"bytes\", Buffer.from(arg, \"utf8\"));\n    } else if (isArray(type)) {\n        // this part handles fixed-length ([2]) and variable length ([]) arrays\n        // NOTE: we catch here all calls to arrays, that simplifies the rest\n        if (typeof arg.length === \"undefined\") {\n            throw new Error(\"Not an array?\");\n        }\n        size = parseTypeArray(type);\n        if (size !== \"dynamic\" && size !== 0 && arg.length > size) {\n            throw new Error(\"Elements exceed array size: \" + size);\n        }\n        ret = [];\n        type = type.slice(0, type.lastIndexOf(\"[\"));\n        if (typeof arg === \"string\") {\n            arg = JSON.parse(arg);\n        }\n        for(i in arg){\n            ret.push(encodeSingle(type, arg[i]));\n        }\n        if (size === \"dynamic\") {\n            var length = encodeSingle(\"uint256\", arg.length);\n            ret.unshift(length);\n        }\n        return Buffer.concat(ret);\n    } else if (type === \"bytes\") {\n        arg = Buffer.from(arg);\n        ret = Buffer.concat([\n            encodeSingle(\"uint256\", arg.length),\n            arg\n        ]);\n        if (arg.length % 32 !== 0) {\n            ret = Buffer.concat([\n                ret,\n                utils.zeros(32 - arg.length % 32)\n            ]);\n        }\n        return ret;\n    } else if (type.startsWith(\"bytes\")) {\n        size = parseTypeN(type);\n        if (size < 1 || size > 32) {\n            throw new Error(\"Invalid bytes<N> width: \" + size);\n        }\n        return utils.setLengthRight(arg, 32);\n    } else if (type.startsWith(\"uint\")) {\n        size = parseTypeN(type);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid uint<N> width: \" + size);\n        }\n        num = parseNumber(arg);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied uint exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        if (num < 0) {\n            throw new Error(\"Supplied uint is negative\");\n        }\n        return num.toArrayLike(Buffer, \"be\", 32);\n    } else if (type.startsWith(\"int\")) {\n        size = parseTypeN(type);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid int<N> width: \" + size);\n        }\n        num = parseNumber(arg);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied int exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        return num.toTwos(256).toArrayLike(Buffer, \"be\", 32);\n    } else if (type.startsWith(\"ufixed\")) {\n        size = parseTypeNxM(type);\n        num = parseNumber(arg);\n        if (num < 0) {\n            throw new Error(\"Supplied ufixed is negative\");\n        }\n        return encodeSingle(\"uint256\", num.mul(new BN(2).pow(new BN(size[1]))));\n    } else if (type.startsWith(\"fixed\")) {\n        size = parseTypeNxM(type);\n        return encodeSingle(\"int256\", parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n    }\n    throw new Error(\"Unsupported or invalid type: \" + type);\n}\n// Decodes a single item (can be dynamic array)\n// @returns: array\n// FIXME: this method will need a lot of attention at checking limits and validation\nfunction decodeSingle(parsedType, data, offset) {\n    if (typeof parsedType === \"string\") {\n        parsedType = parseType(parsedType);\n    }\n    var size, num, ret, i;\n    if (parsedType.name === \"address\") {\n        return decodeSingle(parsedType.rawType, data, offset).toArrayLike(Buffer, \"be\", 20).toString(\"hex\");\n    } else if (parsedType.name === \"bool\") {\n        return decodeSingle(parsedType.rawType, data, offset).toString() === new BN(1).toString();\n    } else if (parsedType.name === \"string\") {\n        var bytes = decodeSingle(parsedType.rawType, data, offset);\n        return Buffer.from(bytes, \"utf8\").toString();\n    } else if (parsedType.isArray) {\n        // this part handles fixed-length arrays ([2]) and variable length ([]) arrays\n        // NOTE: we catch here all calls to arrays, that simplifies the rest\n        ret = [];\n        size = parsedType.size;\n        if (parsedType.size === \"dynamic\") {\n            offset = decodeSingle(\"uint256\", data, offset).toNumber();\n            size = decodeSingle(\"uint256\", data, offset).toNumber();\n            offset = offset + 32;\n        }\n        for(i = 0; i < size; i++){\n            var decoded = decodeSingle(parsedType.subArray, data, offset);\n            ret.push(decoded);\n            offset += parsedType.subArray.memoryUsage;\n        }\n        return ret;\n    } else if (parsedType.name === \"bytes\") {\n        offset = decodeSingle(\"uint256\", data, offset).toNumber();\n        size = decodeSingle(\"uint256\", data, offset).toNumber();\n        return data.slice(offset + 32, offset + 32 + size);\n    } else if (parsedType.name.startsWith(\"bytes\")) {\n        return data.slice(offset, offset + parsedType.size);\n    } else if (parsedType.name.startsWith(\"uint\")) {\n        num = new BN(data.slice(offset, offset + 32), 16, \"be\");\n        if (num.bitLength() > parsedType.size) {\n            throw new Error(\"Decoded int exceeds width: \" + parsedType.size + \" vs \" + num.bitLength());\n        }\n        return num;\n    } else if (parsedType.name.startsWith(\"int\")) {\n        num = new BN(data.slice(offset, offset + 32), 16, \"be\").fromTwos(256);\n        if (num.bitLength() > parsedType.size) {\n            throw new Error(\"Decoded uint exceeds width: \" + parsedType.size + \" vs \" + num.bitLength());\n        }\n        return num;\n    } else if (parsedType.name.startsWith(\"ufixed\")) {\n        size = new BN(2).pow(new BN(parsedType.size[1]));\n        num = decodeSingle(\"uint256\", data, offset);\n        if (!num.mod(size).isZero()) {\n            throw new Error(\"Decimals not supported yet\");\n        }\n        return num.div(size);\n    } else if (parsedType.name.startsWith(\"fixed\")) {\n        size = new BN(2).pow(new BN(parsedType.size[1]));\n        num = decodeSingle(\"int256\", data, offset);\n        if (!num.mod(size).isZero()) {\n            throw new Error(\"Decimals not supported yet\");\n        }\n        return num.div(size);\n    }\n    throw new Error(\"Unsupported or invalid type: \" + parsedType.name);\n}\n// Parse the given type\n// @returns: {} containing the type itself, memory usage and (including size and subArray if applicable)\nfunction parseType(type) {\n    var size;\n    var ret;\n    if (isArray(type)) {\n        size = parseTypeArray(type);\n        var subArray = type.slice(0, type.lastIndexOf(\"[\"));\n        subArray = parseType(subArray);\n        ret = {\n            isArray: true,\n            name: type,\n            size: size,\n            memoryUsage: size === \"dynamic\" ? 32 : subArray.memoryUsage * size,\n            subArray: subArray\n        };\n        return ret;\n    } else {\n        var rawType;\n        switch(type){\n            case \"address\":\n                rawType = \"uint160\";\n                break;\n            case \"bool\":\n                rawType = \"uint8\";\n                break;\n            case \"string\":\n                rawType = \"bytes\";\n                break;\n        }\n        ret = {\n            rawType: rawType,\n            name: type,\n            memoryUsage: 32\n        };\n        if (type.startsWith(\"bytes\") && type !== \"bytes\" || type.startsWith(\"uint\") || type.startsWith(\"int\")) {\n            ret.size = parseTypeN(type);\n        } else if (type.startsWith(\"ufixed\") || type.startsWith(\"fixed\")) {\n            ret.size = parseTypeNxM(type);\n        }\n        if (type.startsWith(\"bytes\") && type !== \"bytes\" && (ret.size < 1 || ret.size > 32)) {\n            throw new Error(\"Invalid bytes<N> width: \" + ret.size);\n        }\n        if ((type.startsWith(\"uint\") || type.startsWith(\"int\")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {\n            throw new Error(\"Invalid int/uint<N> width: \" + ret.size);\n        }\n        return ret;\n    }\n}\n// Is a type dynamic?\nfunction isDynamic(type) {\n    // FIXME: handle all types? I don't think anything is missing now\n    return type === \"string\" || type === \"bytes\" || parseTypeArray(type) === \"dynamic\";\n}\n// Is a type an array?\nfunction isArray(type) {\n    return type.lastIndexOf(\"]\") === type.length - 1;\n}\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nABI.rawEncode = function(types, values) {\n    var output = [];\n    var data = [];\n    var headLength = 0;\n    types.forEach(function(type) {\n        if (isArray(type)) {\n            var size = parseTypeArray(type);\n            if (size !== \"dynamic\") {\n                headLength += 32 * size;\n            } else {\n                headLength += 32;\n            }\n        } else {\n            headLength += 32;\n        }\n    });\n    for(var i = 0; i < types.length; i++){\n        var type = elementaryName(types[i]);\n        var value = values[i];\n        var cur = encodeSingle(type, value);\n        // Use the head/tail method for storing dynamic data\n        if (isDynamic(type)) {\n            output.push(encodeSingle(\"uint256\", headLength));\n            data.push(cur);\n            headLength += cur.length;\n        } else {\n            output.push(cur);\n        }\n    }\n    return Buffer.concat(output.concat(data));\n};\nABI.rawDecode = function(types, data) {\n    var ret = [];\n    data = Buffer.from(data);\n    var offset = 0;\n    for(var i = 0; i < types.length; i++){\n        var type = elementaryName(types[i]);\n        var parsed = parseType(type, data, offset);\n        var decoded = decodeSingle(parsed, data, offset);\n        offset += parsed.memoryUsage;\n        ret.push(decoded);\n    }\n    return ret;\n};\nABI.simpleEncode = function(method) {\n    var args = Array.prototype.slice.call(arguments).slice(1);\n    var sig = parseSignature(method);\n    // FIXME: validate/convert arguments\n    if (args.length !== sig.args.length) {\n        throw new Error(\"Argument count mismatch\");\n    }\n    return Buffer.concat([\n        ABI.methodID(sig.method, sig.args),\n        ABI.rawEncode(sig.args, args)\n    ]);\n};\nABI.simpleDecode = function(method, data) {\n    var sig = parseSignature(method);\n    // FIXME: validate/convert arguments\n    if (!sig.retargs) {\n        throw new Error(\"No return values in method\");\n    }\n    return ABI.rawDecode(sig.retargs, data);\n};\nfunction stringify(type, value) {\n    if (type.startsWith(\"address\") || type.startsWith(\"bytes\")) {\n        return \"0x\" + value.toString(\"hex\");\n    } else {\n        return value.toString();\n    }\n}\nABI.stringify = function(types, values) {\n    var ret = [];\n    for(var i in types){\n        var type = types[i];\n        var value = values[i];\n        // if it is an array type, concat the items\n        if (/^[^\\[]+\\[.*\\]$/.test(type)) {\n            value = value.map(function(item) {\n                return stringify(type, item);\n            }).join(\", \");\n        } else {\n            value = stringify(type, value);\n        }\n        ret.push(value);\n    }\n    return ret;\n};\nABI.solidityHexValue = function(type, value, bitsize) {\n    // pass in bitsize = null if use default bitsize\n    var size, num;\n    if (isArray(type)) {\n        var subType = type.replace(/\\[.*?\\]/, \"\");\n        if (!isArray(subType)) {\n            var arraySize = parseTypeArray(type);\n            if (arraySize !== \"dynamic\" && arraySize !== 0 && value.length > arraySize) {\n                throw new Error(\"Elements exceed array size: \" + arraySize);\n            }\n        }\n        var arrayValues = value.map(function(v) {\n            return ABI.solidityHexValue(subType, v, 256);\n        });\n        return Buffer.concat(arrayValues);\n    } else if (type === \"bytes\") {\n        return value;\n    } else if (type === \"string\") {\n        return Buffer.from(value, \"utf8\");\n    } else if (type === \"bool\") {\n        bitsize = bitsize || 8;\n        var padding = Array(bitsize / 4).join(\"0\");\n        return Buffer.from(value ? padding + \"1\" : padding + \"0\", \"hex\");\n    } else if (type === \"address\") {\n        var bytesize = 20;\n        if (bitsize) {\n            bytesize = bitsize / 8;\n        }\n        return utils.setLengthLeft(value, bytesize);\n    } else if (type.startsWith(\"bytes\")) {\n        size = parseTypeN(type);\n        if (size < 1 || size > 32) {\n            throw new Error(\"Invalid bytes<N> width: \" + size);\n        }\n        return utils.setLengthRight(value, size);\n    } else if (type.startsWith(\"uint\")) {\n        size = parseTypeN(type);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid uint<N> width: \" + size);\n        }\n        num = parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied uint exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        bitsize = bitsize || size;\n        return num.toArrayLike(Buffer, \"be\", bitsize / 8);\n    } else if (type.startsWith(\"int\")) {\n        size = parseTypeN(type);\n        if (size % 8 || size < 8 || size > 256) {\n            throw new Error(\"Invalid int<N> width: \" + size);\n        }\n        num = parseNumber(value);\n        if (num.bitLength() > size) {\n            throw new Error(\"Supplied int exceeds width: \" + size + \" vs \" + num.bitLength());\n        }\n        bitsize = bitsize || size;\n        return num.toTwos(size).toArrayLike(Buffer, \"be\", bitsize / 8);\n    } else {\n        // FIXME: support all other types\n        throw new Error(\"Unsupported or invalid type: \" + type);\n    }\n};\nABI.solidityPack = function(types, values) {\n    if (types.length !== values.length) {\n        throw new Error(\"Number of types are not matching the values\");\n    }\n    var ret = [];\n    for(var i = 0; i < types.length; i++){\n        var type = elementaryName(types[i]);\n        var value = values[i];\n        ret.push(ABI.solidityHexValue(type, value, null));\n    }\n    return Buffer.concat(ret);\n};\nABI.soliditySHA3 = function(types, values) {\n    return utils.keccak256(ABI.solidityPack(types, values));\n};\nABI.soliditySHA256 = function(types, values) {\n    return utils.sha256(ABI.solidityPack(types, values));\n};\nABI.solidityRIPEMD160 = function(types, values) {\n    return utils.ripemd160(ABI.solidityPack(types, values), true);\n};\n// Serpent's users are familiar with this encoding\n// - s: string\n// - b: bytes\n// - b<N>: bytes<N>\n// - i: int256\n// - a: int256[]\nfunction isNumeric(c) {\n    // FIXME: is this correct? Seems to work\n    return c >= \"0\" && c <= \"9\";\n}\n// For a \"documentation\" refer to https://github.com/ethereum/serpent/blob/develop/preprocess.cpp\nABI.fromSerpent = function(sig) {\n    var ret = [];\n    for(var i = 0; i < sig.length; i++){\n        var type = sig[i];\n        if (type === \"s\") {\n            ret.push(\"bytes\");\n        } else if (type === \"b\") {\n            var tmp = \"bytes\";\n            var j = i + 1;\n            while(j < sig.length && isNumeric(sig[j])){\n                tmp += sig[j] - \"0\";\n                j++;\n            }\n            i = j - 1;\n            ret.push(tmp);\n        } else if (type === \"i\") {\n            ret.push(\"int256\");\n        } else if (type === \"a\") {\n            ret.push(\"int256[]\");\n        } else {\n            throw new Error(\"Unsupported or invalid type: \" + type);\n        }\n    }\n    return ret;\n};\nABI.toSerpent = function(types) {\n    var ret = [];\n    for(var i = 0; i < types.length; i++){\n        var type = types[i];\n        if (type === \"bytes\") {\n            ret.push(\"s\");\n        } else if (type.startsWith(\"bytes\")) {\n            ret.push(\"b\" + parseTypeN(type));\n        } else if (type === \"int256\") {\n            ret.push(\"i\");\n        } else if (type === \"int256[]\") {\n            ret.push(\"a\");\n        } else {\n            throw new Error(\"Unsupported or invalid type: \" + type);\n        }\n    }\n    return ret.join(\"\");\n};\nmodule.exports = ABI;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLG9DQUFvQztBQUNwQyxNQUFNQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUN0QixNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQztBQUVuQixJQUFJRSxNQUFNLFlBQ1Y7QUFFQSx3Q0FBd0M7QUFDeEMsc0NBQXNDO0FBQ3RDLFNBQVNDLGVBQWdCQyxJQUFJO0lBQzNCLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxTQUFTO1FBQzNCLE9BQU8sV0FBV0QsS0FBS0UsS0FBSyxDQUFDO0lBQy9CLE9BQU8sSUFBSUYsU0FBUyxPQUFPO1FBQ3pCLE9BQU87SUFDVCxPQUFPLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxVQUFVO1FBQ25DLE9BQU8sWUFBWUQsS0FBS0UsS0FBSyxDQUFDO0lBQ2hDLE9BQU8sSUFBSUYsU0FBUyxRQUFRO1FBQzFCLE9BQU87SUFDVCxPQUFPLElBQUlBLEtBQUtDLFVBQVUsQ0FBQyxXQUFXO1FBQ3BDLE9BQU8saUJBQWlCRCxLQUFLRSxLQUFLLENBQUM7SUFDckMsT0FBTyxJQUFJRixTQUFTLFNBQVM7UUFDM0IsT0FBTztJQUNULE9BQU8sSUFBSUEsS0FBS0MsVUFBVSxDQUFDLFlBQVk7UUFDckMsT0FBTyxrQkFBa0JELEtBQUtFLEtBQUssQ0FBQztJQUN0QyxPQUFPLElBQUlGLFNBQVMsVUFBVTtRQUM1QixPQUFPO0lBQ1Q7SUFDQSxPQUFPQTtBQUNUO0FBRUFGLElBQUlLLE9BQU8sR0FBRyxTQUFVSCxJQUFJLEVBQUVJLEtBQUs7SUFDakMsa0NBQWtDO0lBQ2xDLElBQUlDLE1BQU1MLE9BQU8sTUFBTUksTUFBTUUsR0FBRyxDQUFDUCxnQkFBZ0JRLElBQUksQ0FBQyxPQUFPO0lBQzdELE9BQU9aLE1BQU1hLFNBQVMsQ0FBQ0MsT0FBT0MsSUFBSSxDQUFDTDtBQUNyQztBQUVBUCxJQUFJYSxRQUFRLEdBQUcsU0FBVVgsSUFBSSxFQUFFSSxLQUFL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cUcsRUFBRSxFQUFHO2dCQUM1Q3pGLE9BQU9aLEdBQUcsQ0FBQ3FHLEVBQUUsR0FBRztnQkFDaEJBO1lBQ0Y7WUFDQXJFLElBQUlxRSxJQUFJO1lBQ1J0RSxJQUFJTSxJQUFJLENBQUN6QjtRQUNYLE9BQU8sSUFBSUosU0FBUyxLQUFLO1lBQ3ZCdUIsSUFBSU0sSUFBSSxDQUFDO1FBQ1gsT0FBTyxJQUFJN0IsU0FBUyxLQUFLO1lBQ3ZCdUIsSUFBSU0sSUFBSSxDQUFDO1FBQ1gsT0FBTztZQUNMLE1BQU0sSUFBSWpCLE1BQU0sa0NBQWtDWjtRQUNwRDtJQUNGO0lBQ0EsT0FBT3VCO0FBQ1Q7QUFFQXRDLElBQUk2RyxTQUFTLEdBQUcsU0FBVXZHLEtBQUs7SUFDN0IsSUFBSWdDLE1BQU0sRUFBRTtJQUNaLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJakMsTUFBTXVCLE1BQU0sRUFBRVUsSUFBSztRQUNyQyxJQUFJeEIsT0FBT1QsS0FBSyxDQUFDaUMsRUFBRTtRQUNuQixJQUFJeEIsU0FBUyxTQUFTO1lBQ3BCdUIsSUFBSU0sSUFBSSxDQUFDO1FBQ1gsT0FBTyxJQUFJN0IsS0FBS1osVUFBVSxDQUFDLFVBQVU7WUFDbkNtQyxJQUFJTSxJQUFJLENBQUMsTUFBTTlCLFdBQVdDO1FBQzVCLE9BQU8sSUFBSUEsU0FBUyxVQUFVO1lBQzVCdUIsSUFBSU0sSUFBSSxDQUFDO1FBQ1gsT0FBTyxJQUFJN0IsU0FBUyxZQUFZO1lBQzlCdUIsSUFBSU0sSUFBSSxDQUFDO1FBQ1gsT0FBTztZQUNMLE1BQU0sSUFBSWpCLE1BQU0sa0NBQWtDWjtRQUNwRDtJQUNGO0lBQ0EsT0FBT3VCLElBQUk3QixJQUFJLENBQUM7QUFDbEI7QUFFQXFHLE9BQU9DLE9BQU8sR0FBRy9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlZnJvbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbGliL2luZGV4LmpzPzlkNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdXNlbGVzcy1lc2NhcGUgKi9cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG52YXIgQUJJID0gZnVuY3Rpb24gKCkge1xufVxuXG4vLyBDb252ZXJ0IGZyb20gc2hvcnQgdG8gY2Fub25pY2FsIG5hbWVzXG4vLyBGSVhNRTogb3B0aW1pc2Ugb3IgbWFrZSB0aGlzIG5pY2VyP1xuZnVuY3Rpb24gZWxlbWVudGFyeU5hbWUgKG5hbWUpIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgcmV0dXJuICdpbnQyNTYnICsgbmFtZS5zbGljZSgzKVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgcmV0dXJuICdpbnQyNTYnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgcmV0dXJuICd1aW50MjU2JyArIG5hbWUuc2xpY2UoNClcbiAgfSBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICByZXR1cm4gJ3VpbnQyNTYnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JyArIG5hbWUuc2xpY2UoNSlcbiAgfSBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnXG4gIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICByZXR1cm4gJ3VmaXhlZDEyOHgxMjgnICsgbmFtZS5zbGljZSg2KVxuICB9IGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4J1xuICB9XG4gIHJldHVybiBuYW1lXG59XG5cbkFCSS5ldmVudElEID0gZnVuY3Rpb24gKG5hbWUsIHR5cGVzKSB7XG4gIC8vIEZJWE1FOiB1c2Ugbm9kZS5qcyB1dGlsLmZvcm1hdD9cbiAgdmFyIHNpZyA9IG5hbWUgKyAnKCcgKyB0eXBlcy5tYXAoZWxlbWVudGFyeU5hbWUpLmpvaW4oJywnKSArICcpJ1xuICByZXR1cm4gdXRpbHMua2VjY2FrMjU2KEJ1ZmZlci5mcm9tKHNpZykpXG59XG5cbkFCSS5tZXRob2RJRCA9IGZ1bmN0aW9uIChuYW1lLCB0eXBlcykge1xuICByZXR1cm4gQUJJLmV2ZW50SUQobmFtZSwgdHlwZXMpLnNsaWNlKDAsIDQpXG59XG5cbi8vIFBhcnNlIE4gZnJvbSB0eXBlPE4+XG5mdW5jdGlvbiBwYXJzZVR5cGVOICh0eXBlKSB7XG4gIHJldHVybiBwYXJzZUludCgvXlxcRCsoXFxkKykkLy5leGVjKHR5cGUpWzFdLCAxMClcbn1cblxuLy8gUGFyc2UgTixNIGZyb20gdHlwZTxOPng8TT5cbmZ1bmN0aW9uIHBhcnNlVHlwZU54TSAodHlwZSkge1xuICB2YXIgdG1wID0gL15cXEQrKFxcZCspeChcXGQrKSQvLmV4ZWModHlwZSlcbiAgcmV0dXJuIFsgcGFyc2VJbnQodG1wWzFdLCAxMCksIHBhcnNlSW50KHRtcFsyXSwgMTApIF1cbn1cblxuLy8gUGFyc2UgTiBpbiB0eXBlWzxOPl0gd2hlcmUgXCJ0eXBlXCIgY2FuIGl0c2VsZiBiZSBhbiBhcnJheSB0eXBlLlxuZnVuY3Rpb24gcGFyc2VUeXBlQXJyYXkgKHR5cGUpIHtcbiAgdmFyIHRtcCA9IHR5cGUubWF0Y2goLyguKilcXFsoLio/KVxcXSQvKVxuICBpZiAodG1wKSB7XG4gICAgcmV0dXJuIHRtcFsyXSA9PT0gJycgPyAnZHluYW1pYycgOiBwYXJzZUludCh0bXBbMl0sIDEwKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlTnVtYmVyIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICh1dGlscy5pc0hleFByZWZpeGVkKGFyZykpIHtcbiAgICAgIHJldHVybiBuZXcgQk4odXRpbHMuc3RyaXBIZXhQcmVmaXgoYXJnKSwgMTYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQk4oYXJnLCAxMClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV3IEJOKGFyZylcbiAgfSBlbHNlIGlmIChhcmcudG9BcnJheSkge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgQk4gZm9yIHRoZSBtb21lbnQsIHJlcGxhY2Ugd2l0aCBCTi5pc0JOIHNvb25cbiAgICByZXR1cm4gYXJnXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBudW1iZXInKVxuICB9XG59XG5cbi8vIHNvbWVNZXRob2QoYnl0ZXMsdWludClcbi8vIHNvbWVNZXRob2QoYnl0ZXMsdWludCk6KGJvb2xlYW4pXG5mdW5jdGlvbiBwYXJzZVNpZ25hdHVyZSAoc2lnKSB7XG4gIHZhciB0bXAgPSAvXihcXHcrKVxcKCguKilcXCkkLy5leGVjKHNpZylcblxuICBpZiAodG1wLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlJylcbiAgfVxuXG4gIHZhciBhcmdzID0gL14oLispXFwpOlxcKCguKykkLy5leGVjKHRtcFsyXSlcblxuICBpZiAoYXJncyAhPT0gbnVsbCAmJiBhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IHRtcFsxXSxcbiAgICAgIGFyZ3M6IGFyZ3NbMV0uc3BsaXQoJywnKSxcbiAgICAgIHJldGFyZ3M6IGFyZ3NbMl0uc3BsaXQoJywnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyYW1zID0gdG1wWzJdLnNwbGl0KCcsJylcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gPT09ICcnKSB7XG4gICAgICAvLyBTcGVjaWFsLWNhc2UgKHBvc3NpYmx5IG5haXZlKSBmaXh1cCBmb3IgZnVuY3Rpb25zIHRoYXQgdGFrZSBubyBhcmd1bWVudHMuXG4gICAgICAvLyBUT0RPOiBzcGVjaWFsIGNhc2VzIGFyZSBhbHdheXMgYmFkLCBidXQgdGhpcyBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuXG4gICAgICAvLyBtYXRjaCB3aGF0IHRoZSBjYWxsaW5nIGZ1bmN0aW9ucyBleHBlY3RcbiAgICAgIHBhcmFtcyA9IFtdXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IHRtcFsxXSxcbiAgICAgIGFyZ3M6IHBhcmFtc1xuICAgIH1cbiAgfVxufVxuXG4vLyBFbmNvZGVzIGEgc2luZ2xlIGl0ZW0gKGNhbiBiZSBkeW5hbWljIGFycmF5KVxuLy8gQHJldHVybnM6IEJ1ZmZlclxuZnVuY3Rpb24gZW5jb2RlU2luZ2xlICh0eXBlLCBhcmcpIHtcbiAgdmFyIHNpemUsIG51bSwgcmV0LCBpXG5cbiAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQxNjAnLCBwYXJzZU51bWJlcihhcmcpKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQ4JywgYXJnID8gMSA6IDApXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIEJ1ZmZlci5mcm9tKGFyZywgJ3V0ZjgnKSlcbiAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgLy8gdGhpcyBwYXJ0IGhhbmRsZXMgZml4ZWQtbGVuZ3RoIChbMl0pIGFuZCB2YXJpYWJsZSBsZW5ndGggKFtdKSBhcnJheXNcbiAgICAvLyBOT1RFOiB3ZSBjYXRjaCBoZXJlIGFsbCBjYWxscyB0byBhcnJheXMsIHRoYXQgc2ltcGxpZmllcyB0aGUgcmVzdFxuICAgIGlmICh0eXBlb2YgYXJnLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFuIGFycmF5PycpXG4gICAgfVxuICAgIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKVxuICAgIGlmIChzaXplICE9PSAnZHluYW1pYycgJiYgc2l6ZSAhPT0gMCAmJiBhcmcubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJyArIHNpemUpXG4gICAgfVxuICAgIHJldCA9IFtdXG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKVxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnID0gSlNPTi5wYXJzZShhcmcpXG4gICAgfVxuICAgIGZvciAoaSBpbiBhcmcpIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVNpbmdsZSh0eXBlLCBhcmdbaV0pKVxuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aClcbiAgICAgIHJldC51bnNoaWZ0KGxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICBhcmcgPSBCdWZmZXIuZnJvbShhcmcpXG5cbiAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aCksIGFyZyBdKVxuXG4gICAgaWYgKChhcmcubGVuZ3RoICUgMzIpICE9PSAwKSB7XG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KFsgcmV0LCB1dGlscy56ZXJvcygzMiAtIChhcmcubGVuZ3RoICUgMzIpKSBdKVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlczxOPiB3aWR0aDogJyArIHNpemUpXG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLnNldExlbmd0aFJpZ2h0KGFyZywgMzIpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdWludDxOPiB3aWR0aDogJyArIHNpemUpXG4gICAgfVxuXG4gICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKVxuICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHNpemUgKyAnIHZzICcgKyBudW0uYml0TGVuZ3RoKCkpXG4gICAgfVxuXG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWludCBpcyBuZWdhdGl2ZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKVxuICAgIGlmICgoc2l6ZSAlIDgpIHx8IChzaXplIDwgOCkgfHwgKHNpemUgPiAyNTYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICB9XG5cbiAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgaW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxuICAgIH1cblxuICAgIHJldHVybiBudW0udG9Ud29zKDI1NikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKVxuXG4gICAgbnVtID0gcGFyc2VOdW1iZXIoYXJnKVxuXG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcGxpZWQgdWZpeGVkIGlzIG5lZ2F0aXZlJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgbnVtLm11bChuZXcgQk4oMikucG93KG5ldyBCTihzaXplWzFdKSkpKVxuICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZml4ZWQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOeE0odHlwZSlcblxuICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ2ludDI1NicsIHBhcnNlTnVtYmVyKGFyZykubXVsKG5ldyBCTigyKS5wb3cobmV3IEJOKHNpemVbMV0pKSkpXG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG59XG5cbi8vIERlY29kZXMgYSBzaW5nbGUgaXRlbSAoY2FuIGJlIGR5bmFtaWMgYXJyYXkpXG4vLyBAcmV0dXJuczogYXJyYXlcbi8vIEZJWE1FOiB0aGlzIG1ldGhvZCB3aWxsIG5lZWQgYSBsb3Qgb2YgYXR0ZW50aW9uIGF0IGNoZWNraW5nIGxpbWl0cyBhbmQgdmFsaWRhdGlvblxuZnVuY3Rpb24gZGVjb2RlU2luZ2xlIChwYXJzZWRUeXBlLCBkYXRhLCBvZmZzZXQpIHtcbiAgaWYgKHR5cGVvZiBwYXJzZWRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHBhcnNlZFR5cGUgPSBwYXJzZVR5cGUocGFyc2VkVHlwZSlcbiAgfVxuICB2YXIgc2l6ZSwgbnVtLCByZXQsIGlcblxuICBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnYWRkcmVzcycpIHtcbiAgICByZXR1cm4gZGVjb2RlU2luZ2xlKHBhcnNlZFR5cGUucmF3VHlwZSwgZGF0YSwgb2Zmc2V0KS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDIwKS50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdib29sJykge1xuICAgIHJldHVybiBkZWNvZGVTaW5nbGUocGFyc2VkVHlwZS5yYXdUeXBlLCBkYXRhLCBvZmZzZXQpLnRvU3RyaW5nKCkgPT09IG5ldyBCTigxKS50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgIHZhciBieXRlcyA9IGRlY29kZVNpbmdsZShwYXJzZWRUeXBlLnJhd1R5cGUsIGRhdGEsIG9mZnNldClcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4JykudG9TdHJpbmcoKVxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUuaXNBcnJheSkge1xuICAgIC8vIHRoaXMgcGFydCBoYW5kbGVzIGZpeGVkLWxlbmd0aCBhcnJheXMgKFsyXSkgYW5kIHZhcmlhYmxlIGxlbmd0aCAoW10pIGFycmF5c1xuICAgIC8vIE5PVEU6IHdlIGNhdGNoIGhlcmUgYWxsIGNhbGxzIHRvIGFycmF5cywgdGhhdCBzaW1wbGlmaWVzIHRoZSByZXN0XG4gICAgcmV0ID0gW11cbiAgICBzaXplID0gcGFyc2VkVHlwZS5zaXplXG5cbiAgICBpZiAocGFyc2VkVHlwZS5zaXplID09PSAnZHluYW1pYycpIHtcbiAgICAgIG9mZnNldCA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKVxuICAgICAgc2l6ZSA9IGRlY29kZVNpbmdsZSgndWludDI1NicsIGRhdGEsIG9mZnNldCkudG9OdW1iZXIoKVxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMzJcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVTaW5nbGUocGFyc2VkVHlwZS5zdWJBcnJheSwgZGF0YSwgb2Zmc2V0KVxuICAgICAgcmV0LnB1c2goZGVjb2RlZClcbiAgICAgIG9mZnNldCArPSBwYXJzZWRUeXBlLnN1YkFycmF5Lm1lbW9yeVVzYWdlXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUgPT09ICdieXRlcycpIHtcbiAgICBvZmZzZXQgPSBkZWNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBkYXRhLCBvZmZzZXQpLnRvTnVtYmVyKClcbiAgICBzaXplID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KS50b051bWJlcigpXG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uob2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgc2l6ZSlcbiAgfSBlbHNlIGlmIChwYXJzZWRUeXBlLm5hbWUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcGFyc2VkVHlwZS5zaXplKVxuICB9IGVsc2UgaWYgKHBhcnNlZFR5cGUubmFtZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICBudW0gPSBuZXcgQk4oZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIDMyKSwgMTYsICdiZScpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgcGFyc2VkVHlwZS5zaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxuICAgIH1cbiAgICByZXR1cm4gbnVtXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgbnVtID0gbmV3IEJOKGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAzMiksIDE2LCAnYmUnKS5mcm9tVHdvcygyNTYpXG4gICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHBhcnNlZFR5cGUuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJyArIHBhcnNlZFR5cGUuc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgc2l6ZSA9IG5ldyBCTigyKS5wb3cobmV3IEJOKHBhcnNlZFR5cGUuc2l6ZVsxXSkpXG4gICAgbnVtID0gZGVjb2RlU2luZ2xlKCd1aW50MjU2JywgZGF0YSwgb2Zmc2V0KVxuICAgIGlmICghbnVtLm1vZChzaXplKS5pc1plcm8oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNpbWFscyBub3Qgc3VwcG9ydGVkIHlldCcpXG4gICAgfVxuICAgIHJldHVybiBudW0uZGl2KHNpemUpXG4gIH0gZWxzZSBpZiAocGFyc2VkVHlwZS5uYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcbiAgICBzaXplID0gbmV3IEJOKDIpLnBvdyhuZXcgQk4ocGFyc2VkVHlwZS5zaXplWzFdKSlcbiAgICBudW0gPSBkZWNvZGVTaW5nbGUoJ2ludDI1NicsIGRhdGEsIG9mZnNldClcbiAgICBpZiAoIW51bS5tb2Qoc2l6ZSkuaXNaZXJvKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbHMgbm90IHN1cHBvcnRlZCB5ZXQnKVxuICAgIH1cbiAgICByZXR1cm4gbnVtLmRpdihzaXplKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3IgaW52YWxpZCB0eXBlOiAnICsgcGFyc2VkVHlwZS5uYW1lKVxufVxuXG4vLyBQYXJzZSB0aGUgZ2l2ZW4gdHlwZVxuLy8gQHJldHVybnM6IHt9IGNvbnRhaW5pbmcgdGhlIHR5cGUgaXRzZWxmLCBtZW1vcnkgdXNhZ2UgYW5kIChpbmNsdWRpbmcgc2l6ZSBhbmQgc3ViQXJyYXkgaWYgYXBwbGljYWJsZSlcbmZ1bmN0aW9uIHBhcnNlVHlwZSAodHlwZSkge1xuICB2YXIgc2l6ZVxuICB2YXIgcmV0XG4gIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXG4gICAgdmFyIHN1YkFycmF5ID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgc3ViQXJyYXkgPSBwYXJzZVR5cGUoc3ViQXJyYXkpXG4gICAgcmV0ID0ge1xuICAgICAgaXNBcnJheTogdHJ1ZSxcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBzaXplOiBzaXplLFxuICAgICAgbWVtb3J5VXNhZ2U6IHNpemUgPT09ICdkeW5hbWljJyA/IDMyIDogc3ViQXJyYXkubWVtb3J5VXNhZ2UgKiBzaXplLFxuICAgICAgc3ViQXJyYXk6IHN1YkFycmF5XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmF3VHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgIHJhd1R5cGUgPSAndWludDE2MCdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICByYXdUeXBlID0gJ3VpbnQ4J1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmF3VHlwZSA9ICdieXRlcydcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0ID0ge1xuICAgICAgcmF3VHlwZTogcmF3VHlwZSxcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBtZW1vcnlVc2FnZTogMzJcbiAgICB9XG5cbiAgICBpZiAoKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSAmJiB0eXBlICE9PSAnYnl0ZXMnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWZpeGVkJykgfHwgdHlwZS5zdGFydHNXaXRoKCdmaXhlZCcpKSB7XG4gICAgICByZXQuc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKVxuICAgIH1cblxuICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykgJiYgdHlwZSAhPT0gJ2J5dGVzJyAmJiAocmV0LnNpemUgPCAxIHx8IHJldC5zaXplID4gMzIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyByZXQuc2l6ZSlcbiAgICB9XG4gICAgaWYgKCh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSAmJiAocmV0LnNpemUgJSA4IHx8IHJldC5zaXplIDwgOCB8fCByZXQuc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQvdWludDxOPiB3aWR0aDogJyArIHJldC5zaXplKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuLy8gSXMgYSB0eXBlIGR5bmFtaWM/XG5mdW5jdGlvbiBpc0R5bmFtaWMgKHR5cGUpIHtcbiAgLy8gRklYTUU6IGhhbmRsZSBhbGwgdHlwZXM/IEkgZG9uJ3QgdGhpbmsgYW55dGhpbmcgaXMgbWlzc2luZyBub3dcbiAgcmV0dXJuICh0eXBlID09PSAnc3RyaW5nJykgfHwgKHR5cGUgPT09ICdieXRlcycpIHx8IChwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKVxufVxuXG4vLyBJcyBhIHR5cGUgYW4gYXJyYXk/XG5mdW5jdGlvbiBpc0FycmF5ICh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMVxufVxuXG4vLyBFbmNvZGUgYSBtZXRob2QvZXZlbnQgd2l0aCBhcmd1bWVudHNcbi8vIEB0eXBlcyBhbiBhcnJheSBvZiBzdHJpbmcgdHlwZSBuYW1lc1xuLy8gQGFyZ3MgIGFuIGFycmF5IG9mIHRoZSBhcHByb3ByaWF0ZSB2YWx1ZXNcbkFCSS5yYXdFbmNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICB2YXIgb3V0cHV0ID0gW11cbiAgdmFyIGRhdGEgPSBbXVxuXG4gIHZhciBoZWFkTGVuZ3RoID0gMFxuXG4gIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgdmFyIHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKVxuXG4gICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgIGhlYWRMZW5ndGggKz0gMzIgKiBzaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkTGVuZ3RoICs9IDMyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRMZW5ndGggKz0gMzJcbiAgICB9XG4gIH0pXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXG4gICAgdmFyIGN1ciA9IGVuY29kZVNpbmdsZSh0eXBlLCB2YWx1ZSlcblxuICAgIC8vIFVzZSB0aGUgaGVhZC90YWlsIG1ldGhvZCBmb3Igc3RvcmluZyBkeW5hbWljIGRhdGFcbiAgICBpZiAoaXNEeW5hbWljKHR5cGUpKSB7XG4gICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBoZWFkTGVuZ3RoKSlcbiAgICAgIGRhdGEucHVzaChjdXIpXG4gICAgICBoZWFkTGVuZ3RoICs9IGN1ci5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goY3VyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dHB1dC5jb25jYXQoZGF0YSkpXG59XG5cbkFCSS5yYXdEZWNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIGRhdGEpIHtcbiAgdmFyIHJldCA9IFtdXG4gIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICB2YXIgb2Zmc2V0ID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSlcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VUeXBlKHR5cGUsIGRhdGEsIG9mZnNldClcbiAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVNpbmdsZShwYXJzZWQsIGRhdGEsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gcGFyc2VkLm1lbW9yeVVzYWdlXG4gICAgcmV0LnB1c2goZGVjb2RlZClcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkFCSS5zaW1wbGVFbmNvZGUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgxKVxuICB2YXIgc2lnID0gcGFyc2VTaWduYXR1cmUobWV0aG9kKVxuXG4gIC8vIEZJWE1FOiB2YWxpZGF0ZS9jb252ZXJ0IGFyZ3VtZW50c1xuICBpZiAoYXJncy5sZW5ndGggIT09IHNpZy5hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgY291bnQgbWlzbWF0Y2gnKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWyBBQkkubWV0aG9kSUQoc2lnLm1ldGhvZCwgc2lnLmFyZ3MpLCBBQkkucmF3RW5jb2RlKHNpZy5hcmdzLCBhcmdzKSBdKVxufVxuXG5BQkkuc2ltcGxlRGVjb2RlID0gZnVuY3Rpb24gKG1ldGhvZCwgZGF0YSkge1xuICB2YXIgc2lnID0gcGFyc2VTaWduYXR1cmUobWV0aG9kKVxuXG4gIC8vIEZJWE1FOiB2YWxpZGF0ZS9jb252ZXJ0IGFyZ3VtZW50c1xuICBpZiAoIXNpZy5yZXRhcmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXR1cm4gdmFsdWVzIGluIG1ldGhvZCcpXG4gIH1cblxuICByZXR1cm4gQUJJLnJhd0RlY29kZShzaWcucmV0YXJncywgZGF0YSlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5ICh0eXBlLCB2YWx1ZSkge1xuICBpZiAodHlwZS5zdGFydHNXaXRoKCdhZGRyZXNzJykgfHwgdHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgcmV0dXJuICcweCcgKyB2YWx1ZS50b1N0cmluZygnaGV4JylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKVxuICB9XG59XG5cbkFCSS5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICB2YXIgcmV0ID0gW11cblxuICBmb3IgKHZhciBpIGluIHR5cGVzKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlc1tpXVxuICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXVxuXG4gICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgdHlwZSwgY29uY2F0IHRoZSBpdGVtc1xuICAgIGlmICgvXlteXFxbXStcXFsuKlxcXSQvLnRlc3QodHlwZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkodHlwZSwgaXRlbSlcbiAgICAgIH0pLmpvaW4oJywgJylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBzdHJpbmdpZnkodHlwZSwgdmFsdWUpXG4gICAgfVxuXG4gICAgcmV0LnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gcmV0XG59XG5cbkFCSS5zb2xpZGl0eUhleFZhbHVlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBiaXRzaXplKSB7XG4gIC8vIHBhc3MgaW4gYml0c2l6ZSA9IG51bGwgaWYgdXNlIGRlZmF1bHQgYml0c2l6ZVxuICB2YXIgc2l6ZSwgbnVtXG4gIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgdmFyIHN1YlR5cGUgPSB0eXBlLnJlcGxhY2UoL1xcWy4qP1xcXS8sICcnKVxuICAgIGlmICghaXNBcnJheShzdWJUeXBlKSkge1xuICAgICAgdmFyIGFycmF5U2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpXG4gICAgICBpZiAoYXJyYXlTaXplICE9PSAnZHluYW1pYycgJiYgYXJyYXlTaXplICE9PSAwICYmIHZhbHVlLmxlbmd0aCA+IGFycmF5U2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnRzIGV4Y2VlZCBhcnJheSBzaXplOiAnICsgYXJyYXlTaXplKVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJyYXlWYWx1ZXMgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBBQkkuc29saWRpdHlIZXhWYWx1ZShzdWJUeXBlLCB2LCAyNTYpXG4gICAgfSlcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChhcnJheVZhbHVlcylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4JylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICBiaXRzaXplID0gYml0c2l6ZSB8fCA4XG4gICAgdmFyIHBhZGRpbmcgPSBBcnJheSgoYml0c2l6ZSkgLyA0KS5qb2luKCcwJylcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUgPyBwYWRkaW5nICsgJzEnIDogcGFkZGluZyArICcwJywgJ2hleCcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgdmFyIGJ5dGVzaXplID0gMjBcbiAgICBpZiAoYml0c2l6ZSkge1xuICAgICAgYnl0ZXNpemUgPSBiaXRzaXplIC8gOFxuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuc2V0TGVuZ3RoTGVmdCh2YWx1ZSwgYnl0ZXNpemUpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSlcbiAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICcgKyBzaXplKVxuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5zZXRMZW5ndGhSaWdodCh2YWx1ZSwgc2l6ZSlcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1aW50PE4+IHdpZHRoOiAnICsgc2l6ZSlcbiAgICB9XG5cbiAgICBudW0gPSBwYXJzZU51bWJlcih2YWx1ZSlcbiAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGV4Y2VlZHMgd2lkdGg6ICcgKyBzaXplICsgJyB2cyAnICsgbnVtLmJpdExlbmd0aCgpKVxuICAgIH1cblxuICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IHNpemVcbiAgICByZXR1cm4gbnVtLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgYml0c2l6ZSAvIDgpXG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgIHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpXG4gICAgaWYgKChzaXplICUgOCkgfHwgKHNpemUgPCA4KSB8fCAoc2l6ZSA+IDI1NikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICcgKyBzaXplKVxuICAgIH1cblxuICAgIG51bSA9IHBhcnNlTnVtYmVyKHZhbHVlKVxuICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAnICsgc2l6ZSArICcgdnMgJyArIG51bS5iaXRMZW5ndGgoKSlcbiAgICB9XG5cbiAgICBiaXRzaXplID0gYml0c2l6ZSB8fCBzaXplXG4gICAgcmV0dXJuIG51bS50b1R3b3Moc2l6ZSkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCBiaXRzaXplIC8gOClcbiAgfSBlbHNlIHtcbiAgICAvLyBGSVhNRTogc3VwcG9ydCBhbGwgb3RoZXIgdHlwZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG4gIH1cbn1cblxuQUJJLnNvbGlkaXR5UGFjayA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XG4gIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciBvZiB0eXBlcyBhcmUgbm90IG1hdGNoaW5nIHRoZSB2YWx1ZXMnKVxuICB9XG5cbiAgdmFyIHJldCA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pXG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldXG4gICAgcmV0LnB1c2goQUJJLnNvbGlkaXR5SGV4VmFsdWUodHlwZSwgdmFsdWUsIG51bGwpKVxuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KVxufVxuXG5BQkkuc29saWRpdHlTSEEzID0gZnVuY3Rpb24gKHR5cGVzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmtlY2NhazI1NihBQkkuc29saWRpdHlQYWNrKHR5cGVzLCB2YWx1ZXMpKVxufVxuXG5BQkkuc29saWRpdHlTSEEyNTYgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuICByZXR1cm4gdXRpbHMuc2hhMjU2KEFCSS5zb2xpZGl0eVBhY2sodHlwZXMsIHZhbHVlcykpXG59XG5cbkFCSS5zb2xpZGl0eVJJUEVNRDE2MCA9IGZ1bmN0aW9uICh0eXBlcywgdmFsdWVzKSB7XG4gIHJldHVybiB1dGlscy5yaXBlbWQxNjAoQUJJLnNvbGlkaXR5UGFjayh0eXBlcywgdmFsdWVzKSwgdHJ1ZSlcbn1cblxuLy8gU2VycGVudCdzIHVzZXJzIGFyZSBmYW1pbGlhciB3aXRoIHRoaXMgZW5jb2Rpbmdcbi8vIC0gczogc3RyaW5nXG4vLyAtIGI6IGJ5dGVzXG4vLyAtIGI8Tj46IGJ5dGVzPE4+XG4vLyAtIGk6IGludDI1NlxuLy8gLSBhOiBpbnQyNTZbXVxuXG5mdW5jdGlvbiBpc051bWVyaWMgKGMpIHtcbiAgLy8gRklYTUU6IGlzIHRoaXMgY29ycmVjdD8gU2VlbXMgdG8gd29ya1xuICByZXR1cm4gKGMgPj0gJzAnKSAmJiAoYyA8PSAnOScpXG59XG5cbi8vIEZvciBhIFwiZG9jdW1lbnRhdGlvblwiIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9zZXJwZW50L2Jsb2IvZGV2ZWxvcC9wcmVwcm9jZXNzLmNwcFxuQUJJLmZyb21TZXJwZW50ID0gZnVuY3Rpb24gKHNpZykge1xuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZSA9IHNpZ1tpXVxuICAgIGlmICh0eXBlID09PSAncycpIHtcbiAgICAgIHJldC5wdXNoKCdieXRlcycpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYicpIHtcbiAgICAgIHZhciB0bXAgPSAnYnl0ZXMnXG4gICAgICB2YXIgaiA9IGkgKyAxXG4gICAgICB3aGlsZSAoKGogPCBzaWcubGVuZ3RoKSAmJiBpc051bWVyaWMoc2lnW2pdKSkge1xuICAgICAgICB0bXAgKz0gc2lnW2pdIC0gJzAnXG4gICAgICAgIGorK1xuICAgICAgfVxuICAgICAgaSA9IGogLSAxXG4gICAgICByZXQucHVzaCh0bXApXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnaScpIHtcbiAgICAgIHJldC5wdXNoKCdpbnQyNTYnKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2EnKSB7XG4gICAgICByZXQucHVzaCgnaW50MjU2W10nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJyArIHR5cGUpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQUJJLnRvU2VycGVudCA9IGZ1bmN0aW9uICh0eXBlcykge1xuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0eXBlID0gdHlwZXNbaV1cbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgcmV0LnB1c2goJ3MnKVxuICAgIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICByZXQucHVzaCgnYicgKyBwYXJzZVR5cGVOKHR5cGUpKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludDI1NicpIHtcbiAgICAgIHJldC5wdXNoKCdpJylcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnQyNTZbXScpIHtcbiAgICAgIHJldC5wdXNoKCdhJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICcgKyB0eXBlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQUJJXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiQk4iLCJBQkkiLCJlbGVtZW50YXJ5TmFtZSIsIm5hbWUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJldmVudElEIiwidHlwZXMiLCJzaWciLCJtYXAiLCJqb2luIiwia2VjY2FrMjU2IiwiQnVmZmVyIiwiZnJvbSIsIm1ldGhvZElEIiwicGFyc2VUeXBlTiIsInR5cGUiLCJwYXJzZUludCIsImV4ZWMiLCJwYXJzZVR5cGVOeE0iLCJ0bXAiLCJwYXJzZVR5cGVBcnJheSIsIm1hdGNoIiwicGFyc2VOdW1iZXIiLCJhcmciLCJpc0hleFByZWZpeGVkIiwic3RyaXBIZXhQcmVmaXgiLCJ0b0FycmF5IiwiRXJyb3IiLCJwYXJzZVNpZ25hdHVyZSIsImxlbmd0aCIsImFyZ3MiLCJtZXRob2QiLCJzcGxpdCIsInJldGFyZ3MiLCJwYXJhbXMiLCJlbmNvZGVTaW5nbGUiLCJzaXplIiwibnVtIiwicmV0IiwiaSIsImlzQXJyYXkiLCJsYXN0SW5kZXhPZiIsIkpTT04iLCJwYXJzZSIsInB1c2giLCJ1bnNoaWZ0IiwiY29uY2F0IiwiemVyb3MiLCJzZXRMZW5ndGhSaWdodCIsImJpdExlbmd0aCIsInRvQXJyYXlMaWtlIiwidG9Ud29zIiwibXVsIiwicG93IiwiZGVjb2RlU2luZ2xlIiwicGFyc2VkVHlwZSIsImRhdGEiLCJvZmZzZXQiLCJwYXJzZVR5cGUiLCJyYXdUeXBlIiwidG9TdHJpbmciLCJieXRlcyIsInRvTnVtYmVyIiwiZGVjb2RlZCIsInN1YkFycmF5IiwibWVtb3J5VXNhZ2UiLCJmcm9tVHdvcyIsIm1vZCIsImlzWmVybyIsImRpdiIsImlzRHluYW1pYyIsInJhd0VuY29kZSIsInZhbHVlcyIsIm91dHB1dCIsImhlYWRMZW5ndGgiLCJmb3JFYWNoIiwidmFsdWUiLCJjdXIiLCJyYXdEZWNvZGUiLCJwYXJzZWQiLCJzaW1wbGVFbmNvZGUiLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJzaW1wbGVEZWNvZGUiLCJzdHJpbmdpZnkiLCJ0ZXN0IiwiaXRlbSIsInNvbGlkaXR5SGV4VmFsdWUiLCJiaXRzaXplIiwic3ViVHlwZSIsInJlcGxhY2UiLCJhcnJheVNpemUiLCJhcnJheVZhbHVlcyIsInYiLCJwYWRkaW5nIiwiYnl0ZXNpemUiLCJzZXRMZW5ndGhMZWZ0Iiwic29saWRpdHlQYWNrIiwic29saWRpdHlTSEEzIiwic29saWRpdHlTSEEyNTYiLCJzaGEyNTYiLCJzb2xpZGl0eVJJUEVNRDE2MCIsInJpcGVtZDE2MCIsImlzTnVtZXJpYyIsImMiLCJmcm9tU2VycGVudCIsImoiLCJ0b1NlcnBlbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar ethjsUtil = __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\");\nvar secp256k1 = __webpack_require__(/*! ./secp256k1v3-adapter */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\");\nvar hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js\");\n/**\n * Returns a zero address.\n */ exports.zeroAddress = function() {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */ exports.isValidAddress = function(address) {\n    return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */ exports.isZeroAddress = function(address) {\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */ exports.toChecksumAddress = function(address, eip1191ChainId) {\n    address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n    var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + \"0x\" : \"\";\n    var hash = hash_1.keccak(prefix + address).toString(\"hex\");\n    var ret = \"0x\";\n    for(var i = 0; i < address.length; i++){\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        } else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */ exports.isValidChecksumAddress = function(address, eip1191ChainId) {\n    return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */ exports.generateAddress = function(from, nonce) {\n    from = bytes_1.toBuffer(from);\n    var nonceBN = new BN(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([\n            from,\n            null\n        ]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([\n        from,\n        Buffer.from(nonceBN.toArray())\n    ]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */ exports.generateAddress2 = function(from, salt, initCode) {\n    var fromBuf = bytes_1.toBuffer(from);\n    var saltBuf = bytes_1.toBuffer(salt);\n    var initCodeBuf = bytes_1.toBuffer(initCode);\n    assert(fromBuf.length === 20);\n    assert(saltBuf.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([\n        Buffer.from(\"ff\", \"hex\"),\n        fromBuf,\n        saltBuf,\n        hash_1.keccak256(initCodeBuf)\n    ]));\n    return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */ exports.isPrecompiled = function(address) {\n    var a = bytes_1.unpad(address);\n    return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */ exports.isValidPrivate = function(privateKey) {\n    return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ exports.isValidPublic = function(publicKey, sanitize) {\n    if (sanitize === void 0) {\n        sanitize = false;\n    }\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1.publicKeyVerify(Buffer.concat([\n            Buffer.from([\n                4\n            ]),\n            publicKey\n        ]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */ exports.pubToAddress = function(pubKey, sanitize) {\n    if (sanitize === void 0) {\n        sanitize = false;\n    }\n    pubKey = bytes_1.toBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n    }\n    assert(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ exports.privateToAddress = function(privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */ exports.privateToPublic = function(privateKey) {\n    privateKey = bytes_1.toBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */ exports.importPublic = function(publicKey) {\n    publicKey = bytes_1.toBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n    }\n    return publicKey;\n}; //# sourceMappingURL=account.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2FjY291bnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSx1QkFBdUIsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSxvQkFBb0IsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSxxQkFBcUIsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSw4QkFBOEIsR0FBR0EseUJBQXlCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUNwWSxJQUFJaUIsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsWUFBWUYsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUcsS0FBS0gsbUJBQU9BLENBQUMsbURBQU87QUFDeEIsSUFBSUksVUFBVUosbUJBQU9BLENBQUMsK0ZBQVM7QUFDL0IsSUFBSUssU0FBU0wsbUJBQU9BLENBQUMsNkZBQVE7QUFDN0I7O0NBRUMsR0FDRGxCLG1CQUFtQixHQUFHO0lBQ2xCLElBQUl3QixnQkFBZ0I7SUFDcEIsSUFBSUMsT0FBT0gsUUFBUUksS0FBSyxDQUFDRjtJQUN6QixPQUFPRixRQUFRSyxXQUFXLENBQUNGO0FBQy9CO0FBQ0E7O0NBRUMsR0FDRHpCLHNCQUFzQixHQUFHLFNBQVU0QixPQUFPO0lBQ3RDLE9BQU8sc0JBQXNCQyxJQUFJLENBQUNEO0FBQ3RDO0FBQ0E7O0NBRUMsR0FDRDVCLHFCQUFxQixHQUFHLFNBQVU0QixPQUFPO0lBQ3JDLElBQUlFLFdBQVc5QixRQUFRZ0IsV0FBVztJQUNsQyxPQUFPYyxhQUFhUixRQUFRUyxZQUFZLENBQUNIO0FBQzdDO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ0Q1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IndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvYWNjb3VudC5qcz9lYzY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBleHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MyID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MgPSB2b2lkIDA7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtYWRhcHRlcicpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbnZhciBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzLlxuICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gICAgdmFyIGFkZHIgPSBieXRlc18xLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICAgIHJldHVybiBieXRlc18xLmJ1ZmZlclRvSGV4KGFkZHIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvby5cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzcy5cbiAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgemVyb0FkZHIgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gICAgcmV0dXJuIHplcm9BZGRyID09PSBieXRlc18xLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIElmIGEgZWlwMTE5MUNoYWluSWQgaXMgcHJvdmlkZWQsIHRoZSBjaGFpbklkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGNoZWNrc3VtIGNhbGN1bGF0aW9uLiBUaGlzXG4gKiBoYXMgdGhlIGVmZmVjdCBvZiBjaGVja3N1bW1lZCBhZGRyZXNzZXMgZm9yIG9uZSBjaGFpbiBoYXZpbmcgaW52YWxpZCBjaGVja3N1bXMgZm9yIG90aGVycy5cbiAqIEZvciBtb3JlIGRldGFpbHMsIGNvbnN1bHQgRUlQLTExOTEuXG4gKlxuICogV0FSTklORzogQ2hlY2tzdW1zIHdpdGggYW5kIHdpdGhvdXQgdGhlIGNoYWluSWQgd2lsbCBkaWZmZXIuIEFzIG9mIDIwMTktMDYtMjYsIHRoZSBtb3N0IGNvbW1vbmx5XG4gKiB1c2VkIHZhcmlhdGlvbiBpbiBFdGhlcmV1bSB3YXMgd2l0aG91dCB0aGUgY2hhaW5JZC4gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICBhZGRyZXNzID0gZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHByZWZpeCA9IGVpcDExOTFDaGFpbklkICE9PSB1bmRlZmluZWQgPyBlaXAxMTkxQ2hhaW5JZC50b1N0cmluZygpICsgJzB4JyA6ICcnO1xuICAgIHZhciBoYXNoID0gaGFzaF8xLmtlY2NhayhwcmVmaXggKyBhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gICAgdmFyIHJldCA9ICcweCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzLlxuICpcbiAqIFNlZSB0b0NoZWNrc3VtQWRkcmVzcycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscyBhYm91dCB0aGUgZWlwMTE5MUNoYWluSWQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcywgZWlwMTE5MUNoYWluSWQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MsIGVpcDExOTFDaGFpbklkKSA9PT0gYWRkcmVzcztcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdC5cbiAqIEBwYXJhbSBmcm9tIFRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICAgIGZyb20gPSBieXRlc18xLnRvQnVmZmVyKGZyb20pO1xuICAgIHZhciBub25jZUJOID0gbmV3IEJOKG5vbmNlKTtcbiAgICBpZiAobm9uY2VCTi5pc1plcm8oKSkge1xuICAgICAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICAgICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBudWxsXSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gICAgcmV0dXJuIGhhc2hfMS5ybHBoYXNoKFtmcm9tLCBCdWZmZXIuZnJvbShub25jZUJOLnRvQXJyYXkoKSldKS5zbGljZSgtMjApO1xufTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3MgZm9yIGEgY29udHJhY3QgY3JlYXRlZCB1c2luZyBDUkVBVEUyLlxuICogQHBhcmFtIGZyb20gVGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHNhbHQgQSBzYWx0XG4gKiBAcGFyYW0gaW5pdENvZGUgVGhlIGluaXQgY29kZSBvZiB0aGUgY29udHJhY3QgYmVpbmcgY3JlYXRlZFxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzczIgPSBmdW5jdGlvbiAoZnJvbSwgc2FsdCwgaW5pdENvZGUpIHtcbiAgICB2YXIgZnJvbUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoZnJvbSk7XG4gICAgdmFyIHNhbHRCdWYgPSBieXRlc18xLnRvQnVmZmVyKHNhbHQpO1xuICAgIHZhciBpbml0Q29kZUJ1ZiA9IGJ5dGVzXzEudG9CdWZmZXIoaW5pdENvZGUpO1xuICAgIGFzc2VydChmcm9tQnVmLmxlbmd0aCA9PT0gMjApO1xuICAgIGFzc2VydChzYWx0QnVmLmxlbmd0aCA9PT0gMzIpO1xuICAgIHZhciBhZGRyZXNzID0gaGFzaF8xLmtlY2NhazI1NihCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnZmYnLCAnaGV4JyksIGZyb21CdWYsIHNhbHRCdWYsIGhhc2hfMS5rZWNjYWsyNTYoaW5pdENvZGVCdWYpXSkpO1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKC0yMCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSkuXG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGEgPSBieXRlc18xLnVucGFkKGFkZHJlc3MpO1xuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHNhbml0aXplIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gICAgaWYgKHNhbml0aXplID09PSB2b2lkIDApIHsgc2FuaXRpemUgPSBmYWxzZTsgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gICAgfVxuICAgIGlmICghc2FuaXRpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0gc2FuaXRpemUgQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICAgIGlmIChzYW5pdGl6ZSA9PT0gdm9pZCAwKSB7IHNhbml0aXplID0gZmFsc2U7IH1cbiAgICBwdWJLZXkgPSBieXRlc18xLnRvQnVmZmVyKHB1YktleSk7XG4gICAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAgIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5leHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGV4cG9ydHMucHViVG9BZGRyZXNzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhleHBvcnRzLnByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICovXG5leHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgcHJpdmF0ZUtleSA9IGJ5dGVzXzEudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gICAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIHB1YmxpY0tleSA9IGJ5dGVzXzEudG9CdWZmZXIocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbXBvcnRQdWJsaWMiLCJwcml2YXRlVG9QdWJsaWMiLCJwcml2YXRlVG9BZGRyZXNzIiwicHVibGljVG9BZGRyZXNzIiwicHViVG9BZGRyZXNzIiwiaXNWYWxpZFB1YmxpYyIsImlzVmFsaWRQcml2YXRlIiwiaXNQcmVjb21waWxlZCIsImdlbmVyYXRlQWRkcmVzczIiLCJnZW5lcmF0ZUFkZHJlc3MiLCJpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzIiwidG9DaGVja3N1bUFkZHJlc3MiLCJpc1plcm9BZGRyZXNzIiwiaXNWYWxpZEFkZHJlc3MiLCJ6ZXJvQWRkcmVzcyIsImFzc2VydCIsInJlcXVpcmUiLCJldGhqc1V0aWwiLCJzZWNwMjU2azEiLCJCTiIsImJ5dGVzXzEiLCJoYXNoXzEiLCJhZGRyZXNzTGVuZ3RoIiwiYWRkciIsInplcm9zIiwiYnVmZmVyVG9IZXgiLCJhZGRyZXNzIiwidGVzdCIsInplcm9BZGRyIiwiYWRkSGV4UHJlZml4IiwiZWlwMTE5MUNoYWluSWQiLCJzdHJpcEhleFByZWZpeCIsInRvTG93ZXJDYXNlIiwicHJlZml4IiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJoYXNoIiwia2VjY2FrIiwicmV0IiwiaSIsImxlbmd0aCIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJmcm9tIiwibm9uY2UiLCJ0b0J1ZmZlciIsIm5vbmNlQk4iLCJpc1plcm8iLCJybHBoYXNoIiwic2xpY2UiLCJCdWZmZXIiLCJ0b0FycmF5Iiwic2FsdCIsImluaXRDb2RlIiwiZnJvbUJ1ZiIsInNhbHRCdWYiLCJpbml0Q29kZUJ1ZiIsImtlY2NhazI1NiIsImNvbmNhdCIsImEiLCJ1bnBhZCIsInByaXZhdGVLZXkiLCJwcml2YXRlS2V5VmVyaWZ5IiwicHVibGljS2V5Iiwic2FuaXRpemUiLCJwdWJsaWNLZXlWZXJpZnkiLCJwdWJLZXkiLCJwdWJsaWNLZXlDb252ZXJ0IiwicHVibGljS2V5Q3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;\nvar ethjsUtil = __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/**\n * Returns a buffer filled with 0s.\n * @param bytes the number of bytes the buffer should be\n */ exports.zeros = function(bytes) {\n    return Buffer.allocUnsafe(bytes).fill(0);\n};\n/**\n * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @param right whether to start padding form the left or right\n * @return (Buffer|Array)\n */ exports.setLengthLeft = function(msg, length, right) {\n    if (right === void 0) {\n        right = false;\n    }\n    var buf = exports.zeros(length);\n    msg = exports.toBuffer(msg);\n    if (right) {\n        if (msg.length < length) {\n            msg.copy(buf);\n            return buf;\n        }\n        return msg.slice(0, length);\n    } else {\n        if (msg.length < length) {\n            msg.copy(buf, length - msg.length);\n            return buf;\n        }\n        return msg.slice(-length);\n    }\n};\nexports.setLength = exports.setLengthLeft;\n/**\n * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param msg the value to pad (Buffer|Array)\n * @param length the number of bytes the output should be\n * @return (Buffer|Array)\n */ exports.setLengthRight = function(msg, length) {\n    return exports.setLength(msg, length, true);\n};\n/**\n * Trims leading zeros from a `Buffer` or an `Array`.\n * @param a (Buffer|Array|String)\n * @return (Buffer|Array|String)\n */ exports.unpad = function(a) {\n    a = ethjsUtil.stripHexPrefix(a);\n    var first = a[0];\n    while(a.length > 0 && first.toString() === \"0\"){\n        a = a.slice(1);\n        first = a[0];\n    }\n    return a;\n};\nexports.stripZeros = exports.unpad;\n/**\n * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.\n * @param v the value\n */ exports.toBuffer = function(v) {\n    if (!Buffer.isBuffer(v)) {\n        if (Array.isArray(v)) {\n            v = Buffer.from(v);\n        } else if (typeof v === \"string\") {\n            if (ethjsUtil.isHexString(v)) {\n                v = Buffer.from(ethjsUtil.padToEven(ethjsUtil.stripHexPrefix(v)), \"hex\");\n            } else {\n                throw new Error(\"Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: \" + v);\n            }\n        } else if (typeof v === \"number\") {\n            v = ethjsUtil.intToBuffer(v);\n        } else if (v === null || v === undefined) {\n            v = Buffer.allocUnsafe(0);\n        } else if (BN.isBN(v)) {\n            v = v.toArrayLike(Buffer);\n        } else if (v.toArray) {\n            // converts a BN to a Buffer\n            v = Buffer.from(v.toArray());\n        } else {\n            throw new Error(\"invalid type\");\n        }\n    }\n    return v;\n};\n/**\n * Converts a `Buffer` to a `Number`.\n * @param buf `Buffer` object to convert\n * @throws If the input number exceeds 53 bits.\n */ exports.bufferToInt = function(buf) {\n    return new BN(exports.toBuffer(buf)).toNumber();\n};\n/**\n * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n * @param buf `Buffer` object to convert\n */ exports.bufferToHex = function(buf) {\n    buf = exports.toBuffer(buf);\n    return \"0x\" + buf.toString(\"hex\");\n};\n/**\n * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.\n * @param num Signed integer value\n */ exports.fromSigned = function(num) {\n    return new BN(num).fromTwos(256);\n};\n/**\n * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.\n * @param num\n */ exports.toUnsigned = function(num) {\n    return Buffer.from(num.toTwos(256).toArray());\n};\n/**\n * Adds \"0x\" to a given `String` if it does not already start with \"0x\".\n */ exports.addHexPrefix = function(str) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    return ethjsUtil.isHexPrefixed(str) ? str : \"0x\" + str;\n};\n/**\n * Converts a `Buffer` or `Array` to JSON.\n * @param ba (Buffer|Array)\n * @return (Array|String|null)\n */ exports.baToJSON = function(ba) {\n    if (Buffer.isBuffer(ba)) {\n        return \"0x\" + ba.toString(\"hex\");\n    } else if (ba instanceof Array) {\n        var array = [];\n        for(var i = 0; i < ba.length; i++){\n            array.push(exports.baToJSON(ba[i]));\n        }\n        return array;\n    }\n}; //# sourceMappingURL=bytes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2J5dGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsbUJBQW1CLEdBQUdBLG1CQUFtQixHQUFHQSxnQkFBZ0IsR0FBR0Esa0JBQWtCLEdBQUdBLGFBQWEsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0EsYUFBYSxHQUFHLEtBQUs7QUFDbFIsSUFBSWUsWUFBWUMsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUMsS0FBS0QsbUJBQU9BLENBQUMsbURBQU87QUFDeEI7OztDQUdDLEdBQ0RoQixhQUFhLEdBQUcsU0FBVWtCLEtBQUs7SUFDM0IsT0FBT0MsT0FBT0MsV0FBVyxDQUFDRixPQUFPRyxJQUFJLENBQUM7QUFDMUM7QUFDQTs7Ozs7OztDQU9DLEdBQ0RyQixxQkFBcUIsR0FBRyxTQUFVc0IsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLEtBQUs7SUFDaEQsSUFBSUEsVUFBVSxLQUFLLEdBQUc7UUFBRUEsUUFBUTtJQUFPO0lBQ3ZDLElBQUlDLE1BQU16QixRQUFRYyxLQUFLLENBQUNTO0lBQ3hCRCxNQUFNdEIsUUFBUVEsUUFBUSxDQUFDYztJQUN2QixJQUFJRSxPQUFPO1FBQ1AsSUFBSUYsSUFBSUMsTUFBTSxHQUFHQSxRQUFRO1lBQ3JCRCxJQUFJSSxJQUFJLENBQUNEO1lBQ1QsT0FBT0E7UUFDWDtRQUNBLE9BQU9ILElBQUlLLEtBQUssQ0FBQyxHQUFHSjtJQUN4QixPQUNLO1FBQ0QsSUFBSUQsSUFBSUMsTUFBTSxHQUFHQSxRQUFRO1lBQ3JCRCxJQUFJSSxJQUFJLENBQUNELEtBQUtGLFNBQVNELElBQUlDLE1BQU07WUFDakMsT0FBT0U7UUFD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QUM7SUFDOUIsT0FDSyxJQUFJb0IsY0FBY2pCLE9BQU87UUFDMUIsSUFBSWtCLFFBQVEsRUFBRTtRQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixHQUFHNUIsTUFBTSxFQUFFOEIsSUFBSztZQUNoQ0QsTUFBTUUsSUFBSSxDQUFDdEQsUUFBUUUsUUFBUSxDQUFDaUQsRUFBRSxDQUFDRSxFQUFFO1FBQ3JDO1FBQ0EsT0FBT0Q7SUFDWDtBQUNKLEdBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlZnJvbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2J5dGVzLmpzPzE4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhVG9KU09OID0gZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBleHBvcnRzLnRvVW5zaWduZWQgPSBleHBvcnRzLmZyb21TaWduZWQgPSBleHBvcnRzLmJ1ZmZlclRvSGV4ID0gZXhwb3J0cy5idWZmZXJUb0ludCA9IGV4cG9ydHMudG9CdWZmZXIgPSBleHBvcnRzLnN0cmlwWmVyb3MgPSBleHBvcnRzLnVucGFkID0gZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy56ZXJvcyA9IHZvaWQgMDtcbnZhciBldGhqc1V0aWwgPSByZXF1aXJlKCdldGhqcy11dGlsJyk7XG52YXIgQk4gPSByZXF1aXJlKFwiYm4uanNcIik7XG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHMuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG4vKipcbiAqIExlZnQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0gbXNnIHRoZSB2YWx1ZSB0byBwYWQgKEJ1ZmZlcnxBcnJheSlcbiAqIEBwYXJhbSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHJpZ2h0IHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXkpXG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgPT09IHZvaWQgMCkgeyByaWdodCA9IGZhbHNlOyB9XG4gICAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBtc2cuY29weShidWYpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRMZW5ndGggPSBleHBvcnRzLnNldExlbmd0aExlZnQ7XG4vKipcbiAqIFJpZ2h0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIG1zZyB0aGUgdmFsdWUgdG8gcGFkIChCdWZmZXJ8QXJyYXkpXG4gKiBAcGFyYW0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheSlcbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCBvciBhbiBgQXJyYXlgLlxuICogQHBhcmFtIGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICovXG5leHBvcnRzLnVucGFkID0gZnVuY3Rpb24gKGEpIHtcbiAgICBhID0gZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGEpO1xuICAgIHZhciBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuZXhwb3J0cy5zdHJpcFplcm9zID0gZXhwb3J0cy51bnBhZDtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZVxuICovXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGV0aGpzVXRpbC5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbShldGhqc1V0aWwucGFkVG9FdmVuKGV0aGpzVXRpbC5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogXCIgKyB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHYgPSBldGhqc1V0aWwuaW50VG9CdWZmZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGAweGAtcHJlZml4ZWQgaGV4IGBTdHJpbmdgLlxuICogQHBhcmFtIGJ1ZiBgQnVmZmVyYCBvYmplY3QgdG8gY29udmVydFxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIG51bSBTaWduZWQgaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSBudW1cbiAqL1xuZXhwb3J0cy50b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIi5cbiAqL1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBldGhqc1V0aWwuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OLlxuICogQHBhcmFtIGJhIChCdWZmZXJ8QXJyYXkpXG4gKiBAcmV0dXJuIChBcnJheXxTdHJpbmd8bnVsbClcbiAqL1xuZXhwb3J0cy5iYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYmFUb0pTT04iLCJhZGRIZXhQcmVmaXgiLCJ0b1Vuc2lnbmVkIiwiZnJvbVNpZ25lZCIsImJ1ZmZlclRvSGV4IiwiYnVmZmVyVG9JbnQiLCJ0b0J1ZmZlciIsInN0cmlwWmVyb3MiLCJ1bnBhZCIsInNldExlbmd0aFJpZ2h0Iiwic2V0TGVuZ3RoIiwic2V0TGVuZ3RoTGVmdCIsInplcm9zIiwiZXRoanNVdGlsIiwicmVxdWlyZSIsIkJOIiwiYnl0ZXMiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImZpbGwiLCJtc2ciLCJsZW5ndGgiLCJyaWdodCIsImJ1ZiIsImNvcHkiLCJzbGljZSIsImEiLCJzdHJpcEhleFByZWZpeCIsImZpcnN0IiwidG9TdHJpbmciLCJ2IiwiaXNCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJmcm9tIiwiaXNIZXhTdHJpbmciLCJwYWRUb0V2ZW4iLCJFcnJvciIsImludFRvQnVmZmVyIiwidW5kZWZpbmVkIiwiaXNCTiIsInRvQXJyYXlMaWtlIiwidG9BcnJheSIsInRvTnVtYmVyIiwibnVtIiwiZnJvbVR3b3MiLCJ0b1R3b3MiLCJzdHIiLCJpc0hleFByZWZpeGVkIiwiYmEiLCJhcnJheSIsImkiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\n/**\n * The max integer that this VM can handle\n */ exports.MAX_INTEGER = new BN(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n/**\n * 2^256\n */ exports.TWO_POW256 = new BN(\"10000000000000000000000000000000000000000000000000000000000000000\", 16);\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL_S = \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\";\n/**\n * Keccak-256 hash of null\n */ exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, \"hex\");\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY_S = \"1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\";\n/**\n * Keccak-256 of an RLP of an empty array\n */ exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, \"hex\");\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP_S = \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\";\n/**\n * Keccak-256 hash of the RLP of null\n */ exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, \"hex\"); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLHVCQUF1QixHQUFHQSwyQkFBMkIsR0FBR0EsNkJBQTZCLEdBQUdBLHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0Esa0JBQWtCLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDcE4sSUFBSVUsS0FBS0MsbUJBQU9BLENBQUMsbURBQU87QUFDeEI7O0NBRUMsR0FDRFgsbUJBQW1CLEdBQUcsSUFBSVUsR0FBRyxvRUFBb0U7QUFDakc7O0NBRUMsR0FDRFYsa0JBQWtCLEdBQUcsSUFBSVUsR0FBRyxxRUFBcUU7QUFDakc7O0NBRUMsR0FDRFYsd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsc0JBQXNCLEdBQUdZLE9BQU9DLElBQUksQ0FBQ2IsUUFBUU8sZ0JBQWdCLEVBQUU7QUFDL0Q7O0NBRUMsR0FDRFAsNkJBQTZCLEdBQUc7QUFDaEM7O0NBRUMsR0FDREEsMkJBQTJCLEdBQUdZLE9BQU9DLElBQUksQ0FBQ2IsUUFBUUsscUJBQXFCLEVBQUU7QUFDekU7O0NBRUMsR0FDREwsdUJBQXVCLEdBQUc7QUFDMUI7O0NBRUMsR0FDREEscUJBQXFCLEdBQUdZLE9BQU9DLElBQUksQ0FBQ2IsUUFBUUcsZUFBZSxFQUFFLFFBQzdELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZWZyb250Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9jb25zdGFudHMuanM/YzE3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gZXhwb3J0cy5UV09fUE9XMjU2ID0gZXhwb3J0cy5NQVhfSU5URUdFUiA9IHZvaWQgMDtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbi8qKlxuICogVGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG4vKipcbiAqIDJeMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGxcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3Jztcbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIktFQ0NBSzI1Nl9STFAiLCJLRUNDQUsyNTZfUkxQX1MiLCJLRUNDQUsyNTZfUkxQX0FSUkFZIiwiS0VDQ0FLMjU2X1JMUF9BUlJBWV9TIiwiS0VDQ0FLMjU2X05VTEwiLCJLRUNDQUsyNTZfTlVMTF9TIiwiVFdPX1BPVzI1NiIsIk1BWF9JTlRFR0VSIiwiQk4iLCJyZXF1aXJlIiwiQnVmZmVyIiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;\nvar _a = __webpack_require__(/*! ethereum-cryptography/keccak */ \"(ssr)/./node_modules/ethereum-cryptography/keccak.js\"), keccak224 = _a.keccak224, keccak384 = _a.keccak384, k256 = _a.keccak256, keccak512 = _a.keccak512;\nvar createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nvar ethjsUtil = __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\");\nvar rlp = __webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\");\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Creates Keccak hash of the input\n * @param a The input data (Buffer|Array|String|Number) If the string is a 0x-prefixed hex value\n * it's interpreted as hexadecimal, otherwise as utf8.\n * @param bits The Keccak width\n */ exports.keccak = function(a, bits) {\n    if (bits === void 0) {\n        bits = 256;\n    }\n    if (typeof a === \"string\" && !ethjsUtil.isHexString(a)) {\n        a = Buffer.from(a, \"utf8\");\n    } else {\n        a = bytes_1.toBuffer(a);\n    }\n    if (!bits) bits = 256;\n    switch(bits){\n        case 224:\n            {\n                return keccak224(a);\n            }\n        case 256:\n            {\n                return k256(a);\n            }\n        case 384:\n            {\n                return keccak384(a);\n            }\n        case 512:\n            {\n                return keccak512(a);\n            }\n        default:\n            {\n                throw new Error(\"Invald algorithm: keccak\" + bits);\n            }\n    }\n};\n/**\n * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n * @param a The input data (Buffer|Array|String|Number)\n */ exports.keccak256 = function(a) {\n    return exports.keccak(a);\n};\n/**\n * Creates SHA256 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n */ exports.sha256 = function(a) {\n    a = bytes_1.toBuffer(a);\n    return createHash(\"sha256\").update(a).digest();\n};\n/**\n * Creates RIPEMD160 hash of the input.\n * @param a The input data (Buffer|Array|String|Number)\n * @param padded Whether it should be padded to 256 bits or not\n */ exports.ripemd160 = function(a, padded) {\n    a = bytes_1.toBuffer(a);\n    var hash = createHash(\"rmd160\").update(a).digest();\n    if (padded === true) {\n        return bytes_1.setLength(hash, 32);\n    } else {\n        return hash;\n    }\n};\n/**\n * Creates SHA-3 hash of the RLP encoded version of the input.\n * @param a The input data\n */ exports.rlphash = function(a) {\n    return exports.keccak(rlp.encode(a));\n}; //# sourceMappingURL=hash.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBR0EsaUJBQWlCLEdBQUdBLGNBQWMsR0FBRyxLQUFLO0FBQ2pHLElBQUlPLEtBQUtDLG1CQUFPQSxDQUFDLDZGQUFpQ0MsWUFBWUYsR0FBR0UsU0FBUyxFQUFFQyxZQUFZSCxHQUFHRyxTQUFTLEVBQUVDLE9BQU9KLEdBQUdGLFNBQVMsRUFBRU8sWUFBWUwsR0FBR0ssU0FBUztBQUNuSixJQUFJQyxhQUFhTCxtQkFBT0EsQ0FBQztBQUN6QixJQUFJTSxZQUFZTixtQkFBT0EsQ0FBQztBQUN4QixJQUFJTyxNQUFNUCxtQkFBT0EsQ0FBQyxtREFBSztBQUN2QixJQUFJUSxVQUFVUixtQkFBT0EsQ0FBQywrRkFBUztBQUMvQjs7Ozs7Q0FLQyxHQUNEUixjQUFjLEdBQUcsU0FBVWlCLENBQUMsRUFBRUMsSUFBSTtJQUM5QixJQUFJQSxTQUFTLEtBQUssR0FBRztRQUFFQSxPQUFPO0lBQUs7SUFDbkMsSUFBSSxPQUFPRCxNQUFNLFlBQVksQ0FBQ0gsVUFBVUssV0FBVyxDQUFDRixJQUFJO1FBQ3BEQSxJQUFJRyxPQUFPQyxJQUFJLENBQUNKLEdBQUc7SUFDdkIsT0FDSztRQUNEQSxJQUFJRCxRQUFRTSxRQUFRLENBQUNMO0lBQ3pCO0lBQ0EsSUFBSSxDQUFDQyxNQUNEQSxPQUFPO0lBQ1gsT0FBUUE7UUFDSixLQUFLO1lBQUs7Z0JBQ04sT0FBT1QsVUFBVVE7WUFDckI7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBT04sS0FBS007WUFDaEI7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBT1AsVUFBVU87WUFDckI7UUFDQSxLQUFLO1lBQUs7Z0JBQ04sT0FBT0wsVUFBVUs7WUFDckI7UUFDQTtZQUFTO2dCQUNMLE1BQU0sSUFBSU0sTUFBTSw2QkFBNkJMO1lBQ2pEO0lBQ0o7QUFDSjtBQUNBOzs7Q0FHQyxHQUNEbEIsaUJBQWlCLEdBQUcsU0FBVWlCLENBQUM7SUFDM0IsT0FBT2pCLFFBQVFNLE1BQU0sQ0FBQ1c7QUFDMUI7QUFDQTs7O0NBR0MsR0FDRGpCLGNBQWMsR0FBRyxTQUFVaUIsQ0FBQztJQUN4QkEsSUFBSUQsUUFBUU0sUUFBUSxDQUFDTDtJQUNyQixPQUFPSixXQUFXLFVBQ2JXLE1BQU0sQ0FBQ1AsR0FDUFEsTUFBTTtBQUNmO0FBQ0E7Ozs7Q0FJQyxHQUNEekIsaUJBQWlCLEdBQUcsU0FBVWlCLENBQUMsRUFBRVMsTUFBTTtJQUNuQ1QsSUFBSUQsUUFBUU0sUUFBUSxDQUFDTDtJQUNyQixJQUFJVSxPQUFPZCxXQUFXLFVBQ2pCVyxNQUFNLENBQUNQLEdBQ1BRLE1BQU07SUFDWCxJQUFJQyxXQUFXLE1BQU07UUFDakIsT0FBT1YsUUFBUVksU0FBUyxDQUFDRCxNQUFNO0lBQ25DLE9BQ0s7UUFDRCxPQUFPQTtJQUNYO0FBQ0o7QUFDQTs7O0NBR0MsR0FDRDNCLGVBQWUsR0FBRyxTQUFVaUIsQ0FBQztJQUN6QixPQUFPakIsUUFBUU0sTUFBTSxDQUFDUyxJQUFJYyxNQUFNLENBQUNaO0FBQ3JDLEdBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlZnJvbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2hhc2guanM/NmYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmxwaGFzaCA9IGV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrID0gdm9pZCAwO1xudmFyIF9hID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLCBrZWNjYWsyMjQgPSBfYS5rZWNjYWsyMjQsIGtlY2NhazM4NCA9IF9hLmtlY2NhazM4NCwgazI1NiA9IF9hLmtlY2NhazI1Niwga2VjY2FrNTEyID0gX2Eua2VjY2FrNTEyO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBybHAgPSByZXF1aXJlKFwicmxwXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcikgSWYgdGhlIHN0cmluZyBpcyBhIDB4LXByZWZpeGVkIGhleCB2YWx1ZVxuICogaXQncyBpbnRlcnByZXRlZCBhcyBoZXhhZGVjaW1hbCwgb3RoZXJ3aXNlIGFzIHV0ZjguXG4gKiBAcGFyYW0gYml0cyBUaGUgS2VjY2FrIHdpZHRoXG4gKi9cbmV4cG9ydHMua2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcbiAgICBpZiAoYml0cyA9PT0gdm9pZCAwKSB7IGJpdHMgPSAyNTY7IH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnICYmICFldGhqc1V0aWwuaXNIZXhTdHJpbmcoYSkpIHtcbiAgICAgICAgYSA9IEJ1ZmZlci5mcm9tKGEsICd1dGY4Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhID0gYnl0ZXNfMS50b0J1ZmZlcihhKTtcbiAgICB9XG4gICAgaWYgKCFiaXRzKVxuICAgICAgICBiaXRzID0gMjU2O1xuICAgIHN3aXRjaCAoYml0cykge1xuICAgICAgICBjYXNlIDIyNDoge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazIyNChhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI1Njoge1xuICAgICAgICAgICAgcmV0dXJuIGsyNTYoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzODQ6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWszODQoYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1MTI6IHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWs1MTIoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxkIGFsZ29yaXRobToga2VjY2FrXCIgKyBiaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpLlxuICogQHBhcmFtIGEgVGhlIGlucHV0IGRhdGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyKVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YSAoQnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXIpXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgICBhID0gYnl0ZXNfMS50b0J1ZmZlcihhKTtcbiAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgICAgLnVwZGF0ZShhKVxuICAgICAgICAuZGlnZXN0KCk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBhIFRoZSBpbnB1dCBkYXRhIChCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcilcbiAqIEBwYXJhbSBwYWRkZWQgV2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgICBhID0gYnl0ZXNfMS50b0J1ZmZlcihhKTtcbiAgICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpXG4gICAgICAgIC51cGRhdGUoYSlcbiAgICAgICAgLmRpZ2VzdCgpO1xuICAgIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzXzEuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYSBUaGUgaW5wdXQgZGF0YVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJscGhhc2giLCJyaXBlbWQxNjAiLCJzaGEyNTYiLCJrZWNjYWsyNTYiLCJrZWNjYWsiLCJfYSIsInJlcXVpcmUiLCJrZWNjYWsyMjQiLCJrZWNjYWszODQiLCJrMjU2Iiwia2VjY2FrNTEyIiwiY3JlYXRlSGFzaCIsImV0aGpzVXRpbCIsInJscCIsImJ5dGVzXzEiLCJhIiwiYml0cyIsImlzSGV4U3RyaW5nIiwiQnVmZmVyIiwiZnJvbSIsInRvQnVmZmVyIiwiRXJyb3IiLCJ1cGRhdGUiLCJkaWdlc3QiLCJwYWRkZWQiLCJoYXNoIiwic2V0TGVuZ3RoIiwiZW5jb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.secp256k1 = exports.rlp = exports.BN = void 0;\nvar secp256k1 = __webpack_require__(/*! ./secp256k1v3-adapter */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js\");\nexports.secp256k1 = secp256k1;\nvar ethjsUtil = __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nexports.BN = BN;\nvar rlp = __webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\");\nexports.rlp = rlp;\nObject.assign(exports, ethjsUtil);\n/**\n * Constants\n */ __exportStar(__webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/constants.js\"), exports);\n/**\n * Public-key cryptography (secp256k1) and addresses\n */ __exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/account.js\"), exports);\n/**\n * Hash functions\n */ __exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js\"), exports);\n/**\n * ECDSA signature\n */ __exportStar(__webpack_require__(/*! ./signature */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js\"), exports);\n/**\n * Utilities for manipulating Buffers, byte arrays, etc.\n */ __exportStar(__webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\"), exports);\n/**\n * Function for definining properties on an object\n */ __exportStar(__webpack_require__(/*! ./object */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkosT0FBT08sY0FBYyxDQUFDTCxHQUFHRyxJQUFJO1FBQUVHLFlBQVk7UUFBTUMsS0FBSztZQUFhLE9BQU9OLENBQUMsQ0FBQ0MsRUFBRTtRQUFFO0lBQUU7QUFDdEYsSUFBTSxTQUFTRixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJTSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNQLENBQUMsRUFBRVEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtULEVBQUcsSUFBSVMsTUFBTSxhQUFhLENBQUNELFNBQVFFLGNBQWMsQ0FBQ0QsSUFBSWIsZ0JBQWdCWSxVQUFTUixHQUFHUztBQUNwRztBQUNBWiw4Q0FBNkM7SUFBRWMsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REgsaUJBQWlCLEdBQUdBLFdBQVcsR0FBR0EsVUFBVSxHQUFHLEtBQUs7QUFDcEQsSUFBSUksWUFBWUcsbUJBQU9BLENBQUM7QUFDeEJQLGlCQUFpQixHQUFHSTtBQUNwQixJQUFJSSxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRCxLQUFLQyxtQkFBT0EsQ0FBQyxtREFBTztBQUN4QlAsVUFBVSxHQUFHTTtBQUNiLElBQUlELE1BQU1FLG1CQUFPQSxDQUFDLG1EQUFLO0FBQ3ZCUCxXQUFXLEdBQUdLO0FBQ2RoQixPQUFPb0IsTUFBTSxDQUFDVCxTQUFTUTtBQUN2Qjs7Q0FFQyxHQUNEVCxhQUFhUSxtQkFBT0EsQ0FBQyx1R0FBYSxHQUFHUDtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhUSxtQkFBT0EsQ0FBQyxtR0FBVyxHQUFHUDtBQUNuQzs7Q0FFQyxHQUNERCxhQUFhUSxtQkFBT0EsQ0FBQyw2RkFBUSxHQUFHUDtBQUNoQzs7Q0FFQyxHQUNERCxhQUFhUSxtQkFBT0EsQ0FBQyx1R0FBYSxHQUFHUDtBQUNyQzs7Q0FFQyxHQUNERCxhQUFhUSxtQkFBT0EsQ0FBQywrRkFBUyxHQUFHUDtBQUNqQzs7Q0FFQyxHQUNERCxhQUFhUSxtQkFBT0EsQ0FBQyxpR0FBVSxHQUFHUCxVQUNsQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanM/YjUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VjcDI1NmsxID0gZXhwb3J0cy5ybHAgPSBleHBvcnRzLkJOID0gdm9pZCAwO1xudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxdjMtYWRhcHRlcicpO1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG52YXIgZXRoanNVdGlsID0gcmVxdWlyZSgnZXRoanMtdXRpbCcpO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuZXhwb3J0cy5CTiA9IEJOO1xudmFyIHJscCA9IHJlcXVpcmUoXCJybHBcIik7XG5leHBvcnRzLnJscCA9IHJscDtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgZXRoanNVdGlsKTtcbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25zdGFudHNcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBQdWJsaWMta2V5IGNyeXB0b2dyYXBoeSAoc2VjcDI1NmsxKSBhbmQgYWRkcmVzc2VzXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hY2NvdW50XCIpLCBleHBvcnRzKTtcbi8qKlxuICogSGFzaCBmdW5jdGlvbnNcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hhc2hcIiksIGV4cG9ydHMpO1xuLyoqXG4gKiBFQ0RTQSBzaWduYXR1cmVcbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ25hdHVyZVwiKSwgZXhwb3J0cyk7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbWFuaXB1bGF0aW5nIEJ1ZmZlcnMsIGJ5dGUgYXJyYXlzLCBldGMuXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieXRlc1wiKSwgZXhwb3J0cyk7XG4vKipcbiAqIEZ1bmN0aW9uIGZvciBkZWZpbmluaW5nIHByb3BlcnRpZXMgb24gYW4gb2JqZWN0XG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vYmplY3RcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbHVlIiwic2VjcDI1NmsxIiwicmxwIiwiQk4iLCJyZXF1aXJlIiwiZXRoanNVdGlsIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defineProperties = void 0;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar ethjsUtil = __webpack_require__(/*! ethjs-util */ \"(ssr)/./node_modules/ethjs-util/lib/index.js\");\nvar rlp = __webpack_require__(/*! rlp */ \"(ssr)/./node_modules/rlp/dist/index.js\");\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */ exports.defineProperties = function(self, fields, data) {\n    self.raw = [];\n    self._fields = [];\n    // attach the `toJSON`\n    self.toJSON = function(label) {\n        if (label === void 0) {\n            label = false;\n        }\n        if (label) {\n            var obj_1 = {};\n            self._fields.forEach(function(field) {\n                obj_1[field] = \"0x\" + self[field].toString(\"hex\");\n            });\n            return obj_1;\n        }\n        return bytes_1.baToJSON(self.raw);\n    };\n    self.serialize = function serialize() {\n        return rlp.encode(self.raw);\n    };\n    fields.forEach(function(field, i) {\n        self._fields.push(field.name);\n        function getter() {\n            return self.raw[i];\n        }\n        function setter(v) {\n            v = bytes_1.toBuffer(v);\n            if (v.toString(\"hex\") === \"00\" && !field.allowZero) {\n                v = Buffer.allocUnsafe(0);\n            }\n            if (field.allowLess && field.length) {\n                v = bytes_1.stripZeros(v);\n                assert(field.length >= v.length, \"The field \" + field.name + \" must not have more \" + field.length + \" bytes\");\n            } else if (!(field.allowZero && v.length === 0) && field.length) {\n                assert(field.length === v.length, \"The field \" + field.name + \" must have byte length of \" + field.length);\n            }\n            self.raw[i] = v;\n        }\n        Object.defineProperty(self, field.name, {\n            enumerable: true,\n            configurable: true,\n            get: getter,\n            set: setter\n        });\n        if (field.default) {\n            self[field.name] = field.default;\n        }\n        // attach alias\n        if (field.alias) {\n            Object.defineProperty(self, field.alias, {\n                enumerable: false,\n                configurable: true,\n                set: setter,\n                get: getter\n            });\n        }\n    });\n    // if the constuctor is passed data\n    if (data) {\n        if (typeof data === \"string\") {\n            data = Buffer.from(ethjsUtil.stripHexPrefix(data), \"hex\");\n        }\n        if (Buffer.isBuffer(data)) {\n            data = rlp.decode(data);\n        }\n        if (Array.isArray(data)) {\n            if (data.length > self._fields.length) {\n                throw new Error(\"wrong number of fields in data\");\n            }\n            // make sure all the items are buffers\n            data.forEach(function(d, i) {\n                self[self._fields[i]] = bytes_1.toBuffer(d);\n            });\n        } else if (typeof data === \"object\") {\n            var keys_1 = Object.keys(data);\n            fields.forEach(function(field) {\n                if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n                if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n            });\n        } else {\n            throw new Error(\"invalid data\");\n        }\n    }\n}; //# sourceMappingURL=object.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L29iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxJQUFJRyxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxNQUFNRixtQkFBT0EsQ0FBQyxtREFBSztBQUN2QixJQUFJRyxVQUFVSCxtQkFBT0EsQ0FBQywrRkFBUztBQUMvQjs7Ozs7Ozs7OztDQVVDLEdBQ0RKLHdCQUF3QixHQUFHLFNBQVVRLElBQUksRUFBRUMsTUFBTSxFQUFFQyxJQUFJO0lBQ25ERixLQUFLRyxHQUFHLEdBQUcsRUFBRTtJQUNiSCxLQUFLSSxPQUFPLEdBQUcsRUFBRTtJQUNqQixzQkFBc0I7SUFDdEJKLEtBQUtLLE1BQU0sR0FBRyxTQUFVQyxLQUFLO1FBQ3pCLElBQUlBLFVBQVUsS0FBSyxHQUFHO1lBQUVBLFFBQVE7UUFBTztRQUN2QyxJQUFJQSxPQUFPO1lBQ1AsSUFBSUMsUUFBUSxDQUFDO1lBQ2JQLEtBQUtJLE9BQU8sQ0FBQ0ksT0FBTyxDQUFDLFNBQVVDLEtBQUs7Z0JBQ2hDRixLQUFLLENBQUNFLE1BQU0sR0FBRyxPQUFPVCxJQUFJLENBQUNTLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDO1lBQy9DO1lBQ0EsT0FBT0g7UUFDWDtRQUNBLE9BQU9SLFFBQVFZLFFBQVEsQ0FBQ1gsS0FBS0csR0FBRztJQUNwQztJQUNBSCxLQUFLWSxTQUFTLEdBQUcsU0FBU0E7UUFDdEIsT0FBT2QsSUFBSWUsTUFBTSxDQUFDYixLQUFLRyxHQUFHO0lBQzlCO0lBQ0FGLE9BQU9PLE9BQU8sQ0FBQyxTQUFVQyxLQUFLLEVBQUVLLENBQUM7UUFDN0JkLEtBQUtJLE9BQU8sQ0FBQ1csSUFBSSxDQUFDTixN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LEdBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlZnJvbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L29iamVjdC5qcz9jNzMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGV0aGpzVXRpbCA9IHJlcXVpcmUoJ2V0aGpzLXV0aWwnKTtcbnZhciBybHAgPSByZXF1aXJlKFwicmxwXCIpO1xudmFyIGJ5dGVzXzEgPSByZXF1aXJlKFwiLi9ieXRlc1wiKTtcbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICAgIHNlbGYucmF3ID0gW107XG4gICAgc2VsZi5fZmllbGRzID0gW107XG4gICAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICAgIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gdm9pZCAwKSB7IGxhYmVsID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgb2JqXzEgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIG9ial8xW2ZpZWxkXSA9IFwiMHhcIiArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9ial8xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlc18xLmJhVG9KU09OKHNlbGYucmF3KTtcbiAgICB9O1xuICAgIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gICAgfTtcbiAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICAgICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgICAgICAgdiA9IGJ5dGVzXzEudG9CdWZmZXIodik7XG4gICAgICAgICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHYgPSBieXRlc18xLnN0cmlwWmVyb3Modik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgXCJUaGUgZmllbGQgXCIgKyBmaWVsZC5uYW1lICsgXCIgbXVzdCBub3QgaGF2ZSBtb3JlIFwiICsgZmllbGQubGVuZ3RoICsgXCIgYnl0ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsIFwiVGhlIGZpZWxkIFwiICsgZmllbGQubmFtZSArIFwiIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiBcIiArIGZpZWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgICAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXRoanNVdGlsLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGJ5dGVzXzEudG9CdWZmZXIoZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhciBrZXlzXzEgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzXzEuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYXNzZXJ0IiwicmVxdWlyZSIsImV0aGpzVXRpbCIsInJscCIsImJ5dGVzXzEiLCJzZWxmIiwiZmllbGRzIiwiZGF0YSIsInJhdyIsIl9maWVsZHMiLCJ0b0pTT04iLCJsYWJlbCIsIm9ial8xIiwiZm9yRWFjaCIsImZpZWxkIiwidG9TdHJpbmciLCJiYVRvSlNPTiIsInNlcmlhbGl6ZSIsImVuY29kZSIsImkiLCJwdXNoIiwibmFtZSIsImdldHRlciIsInNldHRlciIsInYiLCJ0b0J1ZmZlciIsImFsbG93WmVybyIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwiYWxsb3dMZXNzIiwibGVuZ3RoIiwic3RyaXBaZXJvcyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJzZXQiLCJkZWZhdWx0IiwiYWxpYXMiLCJmcm9tIiwic3RyaXBIZXhQcmVmaXgiLCJpc0J1ZmZlciIsImRlY29kZSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiZCIsImtleXNfMSIsImtleXMiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\nvar secp256k1 = __webpack_require__(/*! ethereum-cryptography/secp256k1 */ \"(ssr)/./node_modules/ethereum-cryptography/secp256k1.js\");\nvar secp256k1v3 = __webpack_require__(/*! ./secp256k1v3-lib/index */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js\");\nvar der = __webpack_require__(/*! ./secp256k1v3-lib/der */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js\");\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */ exports.privateKeyVerify = function(privateKey) {\n    // secp256k1 v4 version throws when privateKey length is not 32\n    if (privateKey.length !== 32) {\n        return false;\n    }\n    return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */ exports.privateKeyExport = function(privateKey, compressed) {\n    // secp256k1 v4 version throws when privateKey length is not 32\n    if (privateKey.length !== 32) {\n        throw new RangeError(\"private key length is invalid\");\n    }\n    var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n    return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ exports.privateKeyImport = function(privateKey) {\n    // privateKeyImport method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    privateKey = der.privateKeyImport(privateKey);\n    if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n        return privateKey;\n    }\n    throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ exports.privateKeyNegate = function(privateKey) {\n    return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ exports.privateKeyModInverse = function(privateKey) {\n    if (privateKey.length !== 32) {\n        throw new Error(\"private key length is invalid\");\n    }\n    return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */ exports.privateKeyTweakAdd = function(privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */ exports.privateKeyTweakMul = function(privateKey, tweak) {\n    return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.publicKeyCreate = function(privateKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.publicKeyConvert = function(publicKey, compressed) {\n    return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */ exports.publicKeyVerify = function(publicKey) {\n    // secp256k1 v4 version throws when publicKey length is not 33 or 65\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        return false;\n    }\n    return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.publicKeyTweakAdd = function(publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.publicKeyTweakMul = function(publicKey, tweak, compressed) {\n    return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.publicKeyCombine = function(publicKeys, compressed) {\n    var keys = [];\n    publicKeys.forEach(function(publicKey) {\n        keys.push(Uint8Array.from(publicKey));\n    });\n    return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */ exports.signatureNormalize = function(signature) {\n    return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */ exports.signatureExport = function(signature) {\n    return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */ exports.signatureImport = function(signature) {\n    return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */ exports.signatureImportLax = function(signature) {\n    // signatureImportLax method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure that signature is greater than 0\n    if (signature.length === 0) {\n        throw new RangeError(\"signature length is invalid\");\n    }\n    var sigObj = der.signatureImportLax(signature);\n    if (sigObj === null) {\n        throw new Error(\"couldn't parse DER signature\");\n    }\n    return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */ exports.sign = function(message, privateKey, options) {\n    if (options === null) {\n        throw new TypeError(\"options should be an Object\");\n    }\n    var signOptions = undefined;\n    if (options) {\n        signOptions = {};\n        if (options.data === null) {\n            // validate option.data length\n            throw new TypeError(\"options.data should be a Buffer\");\n        }\n        if (options.data) {\n            if (options.data.length != 32) {\n                throw new RangeError(\"options.data length is invalid\");\n            }\n            signOptions.data = new Uint8Array(options.data);\n        }\n        if (options.noncefn === null) {\n            throw new TypeError(\"options.noncefn should be a Function\");\n        }\n        if (options.noncefn) {\n            // convert option.noncefn function signature\n            signOptions.noncefn = function(message, privateKey, algo, data, attempt) {\n                var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n                var bufferData = data != null ? Buffer.from(data) : null;\n                var buffer = Buffer.from(\"\");\n                if (options.noncefn) {\n                    buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n                }\n                return new Uint8Array(buffer);\n            };\n        }\n    }\n    var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n    return {\n        signature: Buffer.from(sig.signature),\n        recovery: sig.recid\n    };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */ exports.verify = function(message, signature, publicKey) {\n    return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */ exports.recover = function(message, signature, recid, compressed) {\n    return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */ exports.ecdh = function(publicKey, privateKey) {\n    // note: secp256k1 v3 doesn't allow optional parameter\n    return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\nexports.ecdhUnsafe = function(publicKey, privateKey, compressed) {\n    // ecdhUnsafe method is not part of secp256k1 v4 package\n    // this implementation is based on v3\n    // ensure valid publicKey length\n    if (publicKey.length !== 33 && publicKey.length !== 65) {\n        throw new RangeError(\"public key length is invalid\");\n    }\n    // ensure valid privateKey length\n    if (privateKey.length !== 32) {\n        throw new RangeError(\"private key length is invalid\");\n    }\n    return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n}; //# sourceMappingURL=secp256k1v3-adapter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxZQUFZLEdBQUdBLGVBQWUsR0FBR0EsY0FBYyxHQUFHQSxZQUFZLEdBQUdBLDBCQUEwQixHQUFHQSx1QkFBdUIsR0FBR0EsdUJBQXVCLEdBQUdBLDBCQUEwQixHQUFHQSx3QkFBd0IsR0FBR0EseUJBQXlCLEdBQUdBLHlCQUF5QixHQUFHQSx1QkFBdUIsR0FBR0Esd0JBQXdCLEdBQUdBLHVCQUF1QixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLDRCQUE0QixHQUFHQSx3QkFBd0IsR0FBR0Esd0JBQXdCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ2hqQixJQUFJd0IsWUFBWUMsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUM7QUFDMUIsSUFBSUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDbEI7Ozs7O0NBS0MsR0FDRHpCLHdCQUF3QixHQUFHLFNBQVU0QixVQUFVO0lBQzNDLCtEQUErRDtJQUMvRCxJQUFJQSxXQUFXQyxNQUFNLEtBQUssSUFBSTtRQUMxQixPQUFPO0lBQ1g7SUFDQSxPQUFPTCxVQUFVRCxnQkFBZ0IsQ0FBQ08sV0FBV0MsSUFBSSxDQUFDSDtBQUN0RDtBQUNBOzs7Ozs7Q0FNQyxHQUNENUIsd0JBQXdCLEdBQUcsU0FBVTRCLFVBQVUsRUFBRUksVUFBVTtJQUN2RCwrREFBK0Q7SUFDL0QsSUFBSUosV0FBV0MsTUFBTSxLQUFLLElBQUk7UUFDMUIsTUFBTSxJQUFJSSxXQUFXO0lBQ3pCO0lBQ0EsSUFBSUMsWUFBWVIsWUFBWUosZ0JBQWdCLENBQUNNLFlBQVlJO0lBQ3pELE9BQU9MLElB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Q0FBQzlCLFdBQVdDLElBQUksQ0FBQ1csWUFBWVosV0FBV0MsSUFBSSxDQUFDYSxVQUFVVjtBQUN2RjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0RsQyxlQUFlLEdBQUcsU0FBVTRDLE9BQU8sRUFBRUYsU0FBUyxFQUFFaUIsS0FBSyxFQUFFM0IsVUFBVTtJQUM3RCxPQUFPSSxPQUFPTCxJQUFJLENBQUNQLFVBQVVxQyxZQUFZLENBQUMvQixXQUFXQyxJQUFJLENBQUNXLFlBQVlpQixPQUFPN0IsV0FBV0MsSUFBSSxDQUFDYSxVQUFVWjtBQUMzRztBQUNBOzs7Ozs7Q0FNQyxHQUNEaEMsWUFBWSxHQUFHLFNBQVVrQyxTQUFTLEVBQUVOLFVBQVU7SUFDMUMsc0RBQXNEO0lBQ3RELE9BQU9RLE9BQU9MLElBQUksQ0FBQ1AsVUFBVXJCLElBQUksQ0FBQzJCLFdBQVdDLElBQUksQ0FBQ0csWUFBWUosV0FBV0MsSUFBSSxDQUFDSCxhQUFhLENBQUM7QUFDaEc7QUFDQTVCLGtCQUFrQixHQUFHLFNBQVVrQyxTQUFTLEVBQUVOLFVBQVUsRUFBRUksVUFBVTtJQUM1RCx3REFBd0Q7SUFDeEQscUNBQXFDO0lBQ3JDLGdDQUFnQztJQUNoQyxJQUFJRSxVQUFVTCxNQUFNLEtBQUssTUFBTUssVUFBVUwsTUFBTSxLQUFLLElBQUk7UUFDcEQsTUFBTSxJQUFJSSxXQUFXO0lBQ3pCO0lBQ0EsaUNBQWlDO0lBQ2pDLElBQUlMLFdBQVdDLE1BQU0sS0FBSyxJQUFJO1FBQzFCLE1BQU0sSUFBSUksV0FBVztJQUN6QjtJQUNBLE9BQU9HLE9BQU9MLElBQUksQ0FBQ0wsWUFBWXhCLFVBQVUsQ0FBQzRCLFdBQVdDLElBQUksQ0FBQ0csWUFBWUosV0FBV0MsSUFBSSxDQUFDSCxhQUFhSTtBQUN2RyxHQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RoZWZyb250Ly4vbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtYWJpL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azF2My1hZGFwdGVyLmpzPzAyNzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVjZGhVbnNhZmUgPSBleHBvcnRzLmVjZGggPSBleHBvcnRzLnJlY292ZXIgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBleHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZXhwb3J0cy5wdWJsaWNLZXlDb21iaW5lID0gZXhwb3J0cy5wdWJsaWNLZXlUd2Vha011bCA9IGV4cG9ydHMucHVibGljS2V5VHdlYWtBZGQgPSBleHBvcnRzLnB1YmxpY0tleVZlcmlmeSA9IGV4cG9ydHMucHVibGljS2V5Q29udmVydCA9IGV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtNdWwgPSBleHBvcnRzLnByaXZhdGVLZXlUd2Vha0FkZCA9IGV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBleHBvcnRzLnByaXZhdGVLZXlOZWdhdGUgPSBleHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBleHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBleHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSB2b2lkIDA7XG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMScpO1xudmFyIHNlY3AyNTZrMXYzID0gcmVxdWlyZSgnLi9zZWNwMjU2azF2My1saWIvaW5kZXgnKTtcbnZhciBkZXIgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWxpYi9kZXInKTtcbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHByaXZhdGVLZXlcbiAqIEBtZXRob2QgcHJpdmF0ZUtleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpO1xufTtcbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMXYzLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCk7XG4gICAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCk7XG59O1xuLyoqXG4gKiBJbXBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAvLyBwcml2YXRlS2V5SW1wb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSk7XG4gICAgaWYgKHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIGV4cG9ydHMucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkge1xuICAgICAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiKTtcbn07XG4vKipcbiAqIE5lZ2F0ZSBhIHByaXZhdGVLZXkgYnkgc3VidHJhY3RpbmcgaXQgZnJvbSB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludFxuICogQG1ldGhvZCBwcml2YXRlS2V5TmVnYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlOZWdhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG4vKipcbiAqIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgYSBwcml2YXRlS2V5IChtb2R1bG8gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnQpLlxuICogQG1ldGhvZCBwcml2YXRlS2V5TW9kSW52ZXJzZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5wcml2YXRlS2V5TW9kSW52ZXJzZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrLlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhaykpKTtcbn07XG4vKipcbiAqIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZUtleS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q3JlYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHVibGljS2V5Q29udmVydCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG59O1xuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsgdmFsdWVcbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG4vKipcbiAqIEFkZCBhIGdpdmVuIHB1YmxpY0tleXMgdG9nZXRoZXIuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbWJpbmVcbiAqIEBwYXJhbSB7QXJyYXk8QnVmZmVyPn0gcHVibGljS2V5c1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBwdWJsaWNLZXlzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShrZXlzLCBjb21wcmVzc2VkKSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcbi8qKlxuICogU2VyaWFsaXplIGFuIEVDRFNBIHNpZ25hdHVyZSBpbiBERVIgZm9ybWF0LlxuICogQG1ldGhvZCBzaWduYXR1cmVFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAoZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgICAvLyBlbnN1cmUgdGhhdCBzaWduYXR1cmUgaXMgZ3JlYXRlciB0aGFuIDBcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2lnbmF0dXJlIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ09iaiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VjcDI1NmsxdjMuc2lnbmF0dXJlSW1wb3J0KHNpZ09iaik7XG59O1xuLyoqXG4gKiBDcmVhdGUgYW4gRUNEU0Egc2lnbmF0dXJlLiBBbHdheXMgcmV0dXJuIGxvdy1TIHNpZ25hdHVyZS5cbiAqIEBtZXRob2Qgc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdCcpO1xuICAgIH1cbiAgICB2YXIgc2lnbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgc2lnbk9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUgb3B0aW9uLmRhdGEgbGVuZ3RoXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5sZW5ndGggIT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWduT3B0aW9ucy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5vbmNlZm4gc2hvdWxkIGJlIGEgRnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IG9wdGlvbi5ub25jZWZuIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgICAgICAgc2lnbk9wdGlvbnMubm9uY2VmbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBhbGdvLCBkYXRhLCBhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckFsZ28gPSBhbGdvICE9IG51bGwgPyBCdWZmZXIuZnJvbShhbGdvKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhICE9IG51bGwgPyBCdWZmZXIuZnJvbShkYXRhKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCcnKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMubm9uY2VmbihCdWZmZXIuZnJvbShtZXNzYWdlKSwgQnVmZmVyLmZyb20ocHJpdmF0ZUtleSksIGJ1ZmZlckFsZ28sIGJ1ZmZlckRhdGEsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNpZyA9IHNlY3AyNTZrMS5lY2RzYVNpZ24oVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHNpZ25PcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5zaWduYXR1cmUpLFxuICAgICAgICByZWNvdmVyeTogc2lnLnJlY2lkLFxuICAgIH07XG59O1xuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQG1ldGhvZCB2ZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLnZlcmlmeSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgcHVibGljS2V5KTtcbn07XG4vKipcbiAqIFJlY292ZXIgYW4gRUNEU0EgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICogQG1ldGhvZCByZWNvdmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJlY2lkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yZWNvdmVyID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjaWQsIGNvbXByZXNzZWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgcmVjaWQsIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgY29tcHJlc3NlZCkpO1xufTtcbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIGFwcGxpZWQgc2hhMjU2IHRvIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAqIEBtZXRob2QgZWNkaFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5lY2RoID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAgIC8vIG5vdGU6IHNlY3AyNTZrMSB2MyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIHBhcmFtZXRlclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB7fSkpO1xufTtcbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAvLyBlY2RoVW5zYWZlIG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgICAvLyBlbnN1cmUgdmFsaWQgcHVibGljS2V5IGxlbmd0aFxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgdmFsaWQgcHJpdmF0ZUtleSBsZW5ndGhcbiAgICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMuZWNkaFVuc2FmZShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxdjMtYWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlY2RoVW5zYWZlIiwiZWNkaCIsInJlY292ZXIiLCJ2ZXJpZnkiLCJzaWduIiwic2lnbmF0dXJlSW1wb3J0TGF4Iiwic2lnbmF0dXJlSW1wb3J0Iiwic2lnbmF0dXJlRXhwb3J0Iiwic2lnbmF0dXJlTm9ybWFsaXplIiwicHVibGljS2V5Q29tYmluZSIsInB1YmxpY0tleVR3ZWFrTXVsIiwicHVibGljS2V5VHdlYWtBZGQiLCJwdWJsaWNLZXlWZXJpZnkiLCJwdWJsaWNLZXlDb252ZXJ0IiwicHVibGljS2V5Q3JlYXRlIiwicHJpdmF0ZUtleVR3ZWFrTXVsIiwicHJpdmF0ZUtleVR3ZWFrQWRkIiwicHJpdmF0ZUtleU1vZEludmVyc2UiLCJwcml2YXRlS2V5TmVnYXRlIiwicHJpdmF0ZUtleUltcG9ydCIsInByaXZhdGVLZXlFeHBvcnQiLCJwcml2YXRlS2V5VmVyaWZ5Iiwic2VjcDI1NmsxIiwicmVxdWlyZSIsInNlY3AyNTZrMXYzIiwiZGVyIiwicHJpdmF0ZUtleSIsImxlbmd0aCIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiY29tcHJlc3NlZCIsIlJhbmdlRXJyb3IiLCJwdWJsaWNLZXkiLCJFcnJvciIsIkJ1ZmZlciIsInR3ZWFrIiwicHVibGljS2V5cyIsImtleXMiLCJmb3JFYWNoIiwicHVzaCIsInNpZ25hdHVyZSIsInNpZ09iaiIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiVHlwZUVycm9yIiwic2lnbk9wdGlvbnMiLCJ1bmRlZmluZWQiLCJkYXRhIiwibm9uY2VmbiIsImFsZ28iLCJhdHRlbXB0IiwiYnVmZmVyQWxnbyIsImJ1ZmZlckRhdGEiLCJidWZmZXIiLCJzaWciLCJlY2RzYVNpZ24iLCJyZWNvdmVyeSIsInJlY2lkIiwiZWNkc2FWZXJpZnkiLCJlY2RzYVJlY292ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([\n    // begin\n    0x30,\n    0x81,\n    0xd3,\n    0x02,\n    0x01,\n    0x01,\n    0x04,\n    0x20,\n    // private key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    // middle\n    0xa0,\n    0x81,\n    0x85,\n    0x30,\n    0x81,\n    0x82,\n    0x02,\n    0x01,\n    0x01,\n    0x30,\n    0x2c,\n    0x06,\n    0x07,\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x01,\n    0x01,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xff,\n    0xff,\n    0xfc,\n    0x2f,\n    0x30,\n    0x06,\n    0x04,\n    0x01,\n    0x00,\n    0x04,\n    0x01,\n    0x07,\n    0x04,\n    0x21,\n    0x02,\n    0x79,\n    0xbe,\n    0x66,\n    0x7e,\n    0xf9,\n    0xdc,\n    0xbb,\n    0xac,\n    0x55,\n    0xa0,\n    0x62,\n    0x95,\n    0xce,\n    0x87,\n    0x0b,\n    0x07,\n    0x02,\n    0x9b,\n    0xfc,\n    0xdb,\n    0x2d,\n    0xce,\n    0x28,\n    0xd9,\n    0x59,\n    0xf2,\n    0x81,\n    0x5b,\n    0x16,\n    0xf8,\n    0x17,\n    0x98,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xba,\n    0xae,\n    0xdc,\n    0xe6,\n    0xaf,\n    0x48,\n    0xa0,\n    0x3b,\n    0xbf,\n    0xd2,\n    0x5e,\n    0x8c,\n    0xd0,\n    0x36,\n    0x41,\n    0x41,\n    0x02,\n    0x01,\n    0x01,\n    0xa1,\n    0x24,\n    0x03,\n    0x22,\n    0x00,\n    // public key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n]);\nvar EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([\n    // begin\n    0x30,\n    0x82,\n    0x01,\n    0x13,\n    0x02,\n    0x01,\n    0x01,\n    0x04,\n    0x20,\n    // private key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    // middle\n    0xa0,\n    0x81,\n    0xa5,\n    0x30,\n    0x81,\n    0xa2,\n    0x02,\n    0x01,\n    0x01,\n    0x30,\n    0x2c,\n    0x06,\n    0x07,\n    0x2a,\n    0x86,\n    0x48,\n    0xce,\n    0x3d,\n    0x01,\n    0x01,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xff,\n    0xff,\n    0xfc,\n    0x2f,\n    0x30,\n    0x06,\n    0x04,\n    0x01,\n    0x00,\n    0x04,\n    0x01,\n    0x07,\n    0x04,\n    0x41,\n    0x04,\n    0x79,\n    0xbe,\n    0x66,\n    0x7e,\n    0xf9,\n    0xdc,\n    0xbb,\n    0xac,\n    0x55,\n    0xa0,\n    0x62,\n    0x95,\n    0xce,\n    0x87,\n    0x0b,\n    0x07,\n    0x02,\n    0x9b,\n    0xfc,\n    0xdb,\n    0x2d,\n    0xce,\n    0x28,\n    0xd9,\n    0x59,\n    0xf2,\n    0x81,\n    0x5b,\n    0x16,\n    0xf8,\n    0x17,\n    0x98,\n    0x48,\n    0x3a,\n    0xda,\n    0x77,\n    0x26,\n    0xa3,\n    0xc4,\n    0x65,\n    0x5d,\n    0xa4,\n    0xfb,\n    0xfc,\n    0x0e,\n    0x11,\n    0x08,\n    0xa8,\n    0xfd,\n    0x17,\n    0xb4,\n    0x48,\n    0xa6,\n    0x85,\n    0x54,\n    0x19,\n    0x9c,\n    0x47,\n    0xd0,\n    0x8f,\n    0xfb,\n    0x10,\n    0xd4,\n    0xb8,\n    0x02,\n    0x21,\n    0x00,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xff,\n    0xfe,\n    0xba,\n    0xae,\n    0xdc,\n    0xe6,\n    0xaf,\n    0x48,\n    0xa0,\n    0x3b,\n    0xbf,\n    0xd2,\n    0x5e,\n    0x8c,\n    0xd0,\n    0x36,\n    0x41,\n    0x41,\n    0x02,\n    0x01,\n    0x01,\n    0xa1,\n    0x44,\n    0x03,\n    0x42,\n    0x00,\n    // public key\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n]);\nexports.privateKeyExport = function(privateKey, publicKey, compressed) {\n    if (compressed === void 0) {\n        compressed = true;\n    }\n    var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);\n    privateKey.copy(result, compressed ? 8 : 9);\n    publicKey.copy(result, compressed ? 181 : 214);\n    return result;\n};\nexports.privateKeyImport = function(privateKey) {\n    var length = privateKey.length;\n    // sequence header\n    var index = 0;\n    if (length < index + 1 || privateKey[index] !== 0x30) return null;\n    index += 1;\n    // sequence length constructor\n    if (length < index + 1 || !(privateKey[index] & 0x80)) return null;\n    var lenb = privateKey[index] & 0x7f;\n    index += 1;\n    if (lenb < 1 || lenb > 2) return null;\n    if (length < index + lenb) return null;\n    // sequence length\n    var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);\n    index += lenb;\n    if (length < index + len) return null;\n    // sequence element 0: version number (=1)\n    if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {\n        return null;\n    }\n    index += 3;\n    // sequence element 1: octet string, up to 32 bytes\n    if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {\n        return null;\n    }\n    return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);\n};\nexports.signatureImportLax = function(signature) {\n    var r = Buffer.alloc(32, 0);\n    var s = Buffer.alloc(32, 0);\n    var length = signature.length;\n    var index = 0;\n    // sequence tag byte\n    if (signature[index++] !== 0x30) {\n        return null;\n    }\n    // sequence length byte\n    var lenbyte = signature[index++];\n    if (lenbyte & 0x80) {\n        index += lenbyte - 0x80;\n        if (index > length) {\n            return null;\n        }\n    }\n    // sequence tag byte for r\n    if (signature[index++] !== 0x02) {\n        return null;\n    }\n    // length for r\n    var rlen = signature[index++];\n    if (rlen & 0x80) {\n        lenbyte = rlen - 0x80;\n        if (index + lenbyte > length) {\n            return null;\n        }\n        for(; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1);\n        for(rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1)rlen = (rlen << 8) + signature[index];\n    }\n    if (rlen > length - index) {\n        return null;\n    }\n    var rindex = index;\n    index += rlen;\n    // sequence tag byte for s\n    if (signature[index++] !== 0x02) {\n        return null;\n    }\n    // length for s\n    var slen = signature[index++];\n    if (slen & 0x80) {\n        lenbyte = slen - 0x80;\n        if (index + lenbyte > length) {\n            return null;\n        }\n        for(; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1);\n        for(slen = 0; lenbyte > 0; index += 1, lenbyte -= 1)slen = (slen << 8) + signature[index];\n    }\n    if (slen > length - index) {\n        return null;\n    }\n    var sindex = index;\n    index += slen;\n    // ignore leading zeros in r\n    for(; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1);\n    // copy r value\n    if (rlen > 32) {\n        return null;\n    }\n    var rvalue = signature.slice(rindex, rindex + rlen);\n    rvalue.copy(r, 32 - rvalue.length);\n    // ignore leading zeros in s\n    for(; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1);\n    // copy s value\n    if (slen > 32) {\n        return null;\n    }\n    var svalue = signature.slice(sindex, sindex + slen);\n    svalue.copy(s, 32 - svalue.length);\n    return {\n        r: r,\n        s: s\n    };\n}; //# sourceMappingURL=der.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWxpYi9kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiwwQ0FBMEM7QUFDMUMscUVBQXFFO0FBQ3JFQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxJQUFJQyxtQ0FBbUNDLE9BQU9DLElBQUksQ0FBQztJQUMvQyxRQUFRO0lBQ1I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLGNBQWM7SUFDZDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUztJQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLGFBQWE7SUFDYjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELElBQUlDLHFDQUFxQ0YsT0FBT0MsSUFBSSxDQUFDO0lBQ2pELFFBQVE7SUFDUjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxjQUFjO0lBQ2Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVM7SUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsYUFBYTtJQUNiO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7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QixJQUFJLENBQUNTLEdBQUcsS0FBS1EsT0FBT2YsTUFBTTtJQUNqQyw0QkFBNEI7SUFDNUIsTUFBT2EsT0FBTyxLQUFLUCxTQUFTLENBQUNRLE9BQU8sS0FBSyxNQUFNRCxRQUFRLEdBQUdDLFVBQVU7SUFFcEUsZUFBZTtJQUNmLElBQUlELE9BQU8sSUFBSTtRQUNYLE9BQU87SUFDWDtJQUNBLElBQUlHLFNBQVNWLFVBQVVGLEtBQUssQ0FBQ1UsUUFBUUEsU0FBU0Q7SUFDOUNHLE9BQU9sQixJQUFJLENBQUNXLEdBQUcsS0FBS08sT0FBT2hCLE1BQU07SUFDakMsT0FBTztRQUFFTyxHQUFHQTtRQUFHRSxHQUFHQTtJQUFFO0FBQ3hCLEdBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlZnJvbnQvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWxpYi9kZXIuanM/ZGEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4gICAgLy8gYmVnaW5cbiAgICAweDMwLFxuICAgIDB4ODEsXG4gICAgMHhkMyxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDA0LFxuICAgIDB4MjAsXG4gICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgLy8gbWlkZGxlXG4gICAgMHhhMCxcbiAgICAweDgxLFxuICAgIDB4ODUsXG4gICAgMHgzMCxcbiAgICAweDgxLFxuICAgIDB4ODIsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgzMCxcbiAgICAweDJjLFxuICAgIDB4MDYsXG4gICAgMHgwNyxcbiAgICAweDJhLFxuICAgIDB4ODYsXG4gICAgMHg0OCxcbiAgICAweGNlLFxuICAgIDB4M2QsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmMsXG4gICAgMHgyZixcbiAgICAweDMwLFxuICAgIDB4MDYsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDAsXG4gICAgMHgwNCxcbiAgICAweDAxLFxuICAgIDB4MDcsXG4gICAgMHgwNCxcbiAgICAweDIxLFxuICAgIDB4MDIsXG4gICAgMHg3OSxcbiAgICAweGJlLFxuICAgIDB4NjYsXG4gICAgMHg3ZSxcbiAgICAweGY5LFxuICAgIDB4ZGMsXG4gICAgMHhiYixcbiAgICAweGFjLFxuICAgIDB4NTUsXG4gICAgMHhhMCxcbiAgICAweDYyLFxuICAgIDB4OTUsXG4gICAgMHhjZSxcbiAgICAweDg3LFxuICAgIDB4MGIsXG4gICAgMHgwNyxcbiAgICAweDAyLFxuICAgIDB4OWIsXG4gICAgMHhmYyxcbiAgICAweGRiLFxuICAgIDB4MmQsXG4gICAgMHhjZSxcbiAgICAweDI4LFxuICAgIDB4ZDksXG4gICAgMHg1OSxcbiAgICAweGYyLFxuICAgIDB4ODEsXG4gICAgMHg1YixcbiAgICAweDE2LFxuICAgIDB4ZjgsXG4gICAgMHgxNyxcbiAgICAweDk4LFxuICAgIDB4MDIsXG4gICAgMHgyMSxcbiAgICAweDAwLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmUsXG4gICAgMHhiYSxcbiAgICAweGFlLFxuICAgIDB4ZGMsXG4gICAgMHhlNixcbiAgICAweGFmLFxuICAgIDB4NDgsXG4gICAgMHhhMCxcbiAgICAweDNiLFxuICAgIDB4YmYsXG4gICAgMHhkMixcbiAgICAweDVlLFxuICAgIDB4OGMsXG4gICAgMHhkMCxcbiAgICAweDM2LFxuICAgIDB4NDEsXG4gICAgMHg0MSxcbiAgICAweDAyLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweGExLFxuICAgIDB4MjQsXG4gICAgMHgwMyxcbiAgICAweDIyLFxuICAgIDB4MDAsXG4gICAgLy8gcHVibGljIGtleVxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuXSk7XG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgICAvLyBiZWdpblxuICAgIDB4MzAsXG4gICAgMHg4MixcbiAgICAweDAxLFxuICAgIDB4MTMsXG4gICAgMHgwMixcbiAgICAweDAxLFxuICAgIDB4MDEsXG4gICAgMHgwNCxcbiAgICAweDIwLFxuICAgIC8vIHByaXZhdGUga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIC8vIG1pZGRsZVxuICAgIDB4YTAsXG4gICAgMHg4MSxcbiAgICAweGE1LFxuICAgIDB4MzAsXG4gICAgMHg4MSxcbiAgICAweGEyLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4MzAsXG4gICAgMHgyYyxcbiAgICAweDA2LFxuICAgIDB4MDcsXG4gICAgMHgyYSxcbiAgICAweDg2LFxuICAgIDB4NDgsXG4gICAgMHhjZSxcbiAgICAweDNkLFxuICAgIDB4MDEsXG4gICAgMHgwMSxcbiAgICAweDAyLFxuICAgIDB4MjEsXG4gICAgMHgwMCxcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZlLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZjLFxuICAgIDB4MmYsXG4gICAgMHgzMCxcbiAgICAweDA2LFxuICAgIDB4MDQsXG4gICAgMHgwMSxcbiAgICAweDAwLFxuICAgIDB4MDQsXG4gICAgMHgwMSxcbiAgICAweDA3LFxuICAgIDB4MDQsXG4gICAgMHg0MSxcbiAgICAweDA0LFxuICAgIDB4NzksXG4gICAgMHhiZSxcbiAgICAweDY2LFxuICAgIDB4N2UsXG4gICAgMHhmOSxcbiAgICAweGRjLFxuICAgIDB4YmIsXG4gICAgMHhhYyxcbiAgICAweDU1LFxuICAgIDB4YTAsXG4gICAgMHg2MixcbiAgICAweDk1LFxuICAgIDB4Y2UsXG4gICAgMHg4NyxcbiAgICAweDBiLFxuICAgIDB4MDcsXG4gICAgMHgwMixcbiAgICAweDliLFxuICAgIDB4ZmMsXG4gICAgMHhkYixcbiAgICAweDJkLFxuICAgIDB4Y2UsXG4gICAgMHgyOCxcbiAgICAweGQ5LFxuICAgIDB4NTksXG4gICAgMHhmMixcbiAgICAweDgxLFxuICAgIDB4NWIsXG4gICAgMHgxNixcbiAgICAweGY4LFxuICAgIDB4MTcsXG4gICAgMHg5OCxcbiAgICAweDQ4LFxuICAgIDB4M2EsXG4gICAgMHhkYSxcbiAgICAweDc3LFxuICAgIDB4MjYsXG4gICAgMHhhMyxcbiAgICAweGM0LFxuICAgIDB4NjUsXG4gICAgMHg1ZCxcbiAgICAweGE0LFxuICAgIDB4ZmIsXG4gICAgMHhmYyxcbiAgICAweDBlLFxuICAgIDB4MTEsXG4gICAgMHgwOCxcbiAgICAweGE4LFxuICAgIDB4ZmQsXG4gICAgMHgxNyxcbiAgICAweGI0LFxuICAgIDB4NDgsXG4gICAgMHhhNixcbiAgICAweDg1LFxuICAgIDB4NTQsXG4gICAgMHgxOSxcbiAgICAweDljLFxuICAgIDB4NDcsXG4gICAgMHhkMCxcbiAgICAweDhmLFxuICAgIDB4ZmIsXG4gICAgMHgxMCxcbiAgICAweGQ0LFxuICAgIDB4YjgsXG4gICAgMHgwMixcbiAgICAweDIxLFxuICAgIDB4MDAsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZixcbiAgICAweGZmLFxuICAgIDB4ZmYsXG4gICAgMHhmZSxcbiAgICAweGJhLFxuICAgIDB4YWUsXG4gICAgMHhkYyxcbiAgICAweGU2LFxuICAgIDB4YWYsXG4gICAgMHg0OCxcbiAgICAweGEwLFxuICAgIDB4M2IsXG4gICAgMHhiZixcbiAgICAweGQyLFxuICAgIDB4NWUsXG4gICAgMHg4YyxcbiAgICAweGQwLFxuICAgIDB4MzYsXG4gICAgMHg0MSxcbiAgICAweDQxLFxuICAgIDB4MDIsXG4gICAgMHgwMSxcbiAgICAweDAxLFxuICAgIDB4YTEsXG4gICAgMHg0NCxcbiAgICAweDAzLFxuICAgIDB4NDIsXG4gICAgMHgwMCxcbiAgICAvLyBwdWJsaWMga2V5XG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuICAgIDB4MDAsXG4gICAgMHgwMCxcbiAgICAweDAwLFxuXSk7XG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuICAgIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShjb21wcmVzc2VkID8gRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgOiBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEKTtcbiAgICBwcml2YXRlS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gOCA6IDkpO1xuICAgIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aDtcbiAgICAvLyBzZXF1ZW5jZSBoZWFkZXJcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGluZGV4ICs9IDE7XG4gICAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmO1xuICAgIGluZGV4ICs9IDE7XG4gICAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW5iKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzZXF1ZW5jZSBsZW5ndGhcbiAgICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICAgIGluZGV4ICs9IGxlbmI7XG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8XG4gICAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGluZGV4ICs9IDM7XG4gICAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gICAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMiB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fFxuICAgICAgICBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8XG4gICAgICAgIGxlbmd0aCA8IGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVLZXkuc2xpY2UoaW5kZXggKyAyLCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pO1xufTtcbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICAgIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MzApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHNlcXVlbmNlIGxlbmd0aCBieXRlXG4gICAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgICAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciByXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gbGVuZ3RoIGZvciByXG4gICAgdmFyIHJsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MDtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICAgIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByaW5kZXggPSBpbmRleDtcbiAgICBpbmRleCArPSBybGVuO1xuICAgIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gICAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gbGVuZ3RoIGZvciBzXG4gICAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gICAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICAgICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSlcbiAgICAgICAgICAgIHNsZW4gPSAoc2xlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICAgIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzaW5kZXggPSBpbmRleDtcbiAgICBpbmRleCArPSBzbGVuO1xuICAgIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnbmF0dXJlW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpXG4gICAgICAgIDtcbiAgICAvLyBjb3B5IHIgdmFsdWVcbiAgICBpZiAocmxlbiA+IDMyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgcnZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbik7XG4gICAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcbiAgICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gICAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ25hdHVyZVtzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKVxuICAgICAgICA7XG4gICAgLy8gY29weSBzIHZhbHVlXG4gICAgaWYgKHNsZW4gPiAzMikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShzaW5kZXgsIHNpbmRleCArIHNsZW4pO1xuICAgIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCIsIkJ1ZmZlciIsImZyb20iLCJFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEIiwicHJpdmF0ZUtleUV4cG9ydCIsInByaXZhdGVLZXkiLCJwdWJsaWNLZXkiLCJjb21wcmVzc2VkIiwicmVzdWx0IiwiY29weSIsInByaXZhdGVLZXlJbXBvcnQiLCJsZW5ndGgiLCJpbmRleCIsImxlbmIiLCJsZW4iLCJzbGljZSIsInNpZ25hdHVyZUltcG9ydExheCIsInNpZ25hdHVyZSIsInIiLCJhbGxvYyIsInMiLCJsZW5ieXRlIiwicmxlbiIsInJpbmRleCIsInNsZW4iLCJzaW5kZXgiLCJydmFsdWUiLCJzdmFsdWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/der.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar EC = (__webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\").ec);\nvar ec = new EC(\"secp256k1\");\nvar ecparams = ec.curve;\nexports.privateKeyExport = function(privateKey, compressed) {\n    if (compressed === void 0) {\n        compressed = true;\n    }\n    var d = new BN(privateKey);\n    if (d.ucmp(ecparams.n) >= 0) {\n        throw new Error(\"couldn't export to DER format\");\n    }\n    var point = ec.g.mul(d);\n    return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function(privateKey) {\n    var bn = new BN(privateKey);\n    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n        throw new Error(\"private key range is invalid\");\n    }\n    return bn.invm(ecparams.n).toArrayLike(Buffer, \"be\", 32);\n};\nexports.signatureImport = function(sigObj) {\n    var r = new BN(sigObj.r);\n    if (r.ucmp(ecparams.n) >= 0) {\n        r = new BN(0);\n    }\n    var s = new BN(sigObj.s);\n    if (s.ucmp(ecparams.n) >= 0) {\n        s = new BN(0);\n    }\n    return Buffer.concat([\n        r.toArrayLike(Buffer, \"be\", 32),\n        s.toArrayLike(Buffer, \"be\", 32)\n    ]);\n};\nexports.ecdhUnsafe = function(publicKey, privateKey, compressed) {\n    if (compressed === void 0) {\n        compressed = true;\n    }\n    var point = ec.keyFromPublic(publicKey);\n    var scalar = new BN(privateKey);\n    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n        throw new Error(\"scalar was invalid (zero or overflow)\");\n    }\n    var shared = point.pub.mul(scalar);\n    return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function(x, y, compressed) {\n    var publicKey;\n    if (compressed) {\n        publicKey = Buffer.alloc(33);\n        publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n        x.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 1);\n    } else {\n        publicKey = Buffer.alloc(65);\n        publicKey[0] = 0x04;\n        x.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 1);\n        y.toArrayLike(Buffer, \"be\", 32).copy(publicKey, 33);\n    }\n    return publicKey;\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMXYzLWxpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDBDQUEwQztBQUMxQyxxRUFBcUU7QUFDckVBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELElBQUlDLEtBQUtDLG1CQUFPQSxDQUFDLG1EQUFPO0FBQ3hCLElBQUlDLEtBQUtELHlGQUFzQjtBQUMvQixJQUFJRSxLQUFLLElBQUlELEdBQUc7QUFDaEIsSUFBSUUsV0FBV0QsR0FBR0UsS0FBSztBQUN2QlAsd0JBQXdCLEdBQUcsU0FBVVMsVUFBVSxFQUFFQyxVQUFVO0lBQ3ZELElBQUlBLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWE7SUFBTTtJQUNoRCxJQUFJQyxJQUFJLElBQUlULEdBQUdPO0lBQ2YsSUFBSUUsRUFBRUMsSUFBSSxDQUFDTixTQUFTTyxDQUFDLEtBQUssR0FBRztRQUN6QixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxJQUFJQyxRQUFRVixHQUFHVyxDQUFDLENBQUNDLEdBQUcsQ0FBQ047SUFDckIsT0FBT08sWUFBWUgsTUFBTUksSUFBSSxJQUFJSixNQUFNSyxJQUFJLElBQUlWO0FBQ25EO0FBQ0FWLDRCQUE0QixHQUFHLFNBQVVTLFVBQVU7SUFDL0MsSUFBSWEsS0FBSyxJQUFJcEIsR0FBR087SUFDaEIsSUFBSWEsR0FBR1YsSUFBSSxDQUFDTixTQUFTTyxDQUFDLEtBQUssS0FBS1MsR0FBR0MsTUFBTSxJQUFJO1FBQ3pDLE1BQU0sSUFBSVQsTUFBTTtJQUNwQjtJQUNBLE9BQU9RLEdBQUdFLElBQUksQ0FBQ2xCLFNBQVNPLENBQUMsRUFBRVksV0FBVyxDQUFDQyxRQUFRLE1BQU07QUFDekQ7QUFDQTFCLHVCQUF1QixHQUFHLFNBQVU0QixNQUFNO0lBQ3RDLElBQUlDLElBQUksSUFBSTNCLEdBQUcwQixPQUFPQyxDQUFDO0lBQ3ZCLElBQUlBLEVBQUVqQixJQUFJLENBQUNOLFNBQVNPLENBQUMsS0FBSyxHQUFHO1FBQ3pCZ0IsSUFBSSxJQUFJM0IsR0FBRztJQUNmO0lBQ0EsSUFBSTRCLElBQUksSUFBSTVCLEdBQUcwQixPQUFPRSxDQUFDO0lBQ3ZCLElBQUlBLEVBQUVsQixJQUFJLENBQUNOLFNBQVNPLENBQUMsS0FBSyxHQUFHO1FBQ3pCaUIsSUFBSSxJQUFJNUIsR0FBRztJQUNmO0lBQ0EsT0FBT3dCLE9BQU9LLE1BQU0sQ0FBQztRQUFDRixFQUFFSixXQUFXLENBQUNDLFFBQVEsTUFBTTtRQUFLSSxFQUFFTCxXQUFXLENBQUNDLFFBQVEsTUFBTTtLQUFJO0FBQzNGO0FBQ0ExQixrQkFBa0IsR0FBRyxTQUFVaUMsU0FBUyxFQUFFeEIsVUFBVSxFQUFFQyxVQUFVO0lBQzVELElBQUlBLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWE7SUFBTTtJQUNoRCxJQUFJSyxRQUFRVixHQUFHNkIsYUFBYSxDQUFDRDtJQUM3QixJQUFJRSxTQUFTLElBQUlqQyxHQUFHTztJQUNwQixJQUFJMEIsT0FBT3ZCLElBQUksQ0FBQ04sU0FBU08sQ0FBQyxLQUFLLEtBQUtzQixPQUFPWixNQUFNLElBQUk7UUFDakQsTUFBTSxJQUFJVCxNQUFNO0lBQ3BCO0lBQ0EsSUFBSXNCLFNBQVNyQixNQUFNc0IsR0FBRyxDQUFDcEIsR0FBRyxDQUFDa0I7SUFDM0IsT0FBT2pCLFlBQVlrQixPQUFPakIsSUFBSSxJQUFJaUIsT0FBT2hCLElBQUksSUFBSVY7QUFDckQ7QUFDQSxJQUFJUSxjQUFjLFNBQVVvQixDQUFDLEVBQUVDLENBQUMsRUFBRTdCLFVBQVU7SUFDeEMsSUFBSXVCO0lBQ0osSUFBSXZCLFlBQVk7UUFDWnVCLFlBQVlQLE9BQU9jLEtBQUssQ0FBQztRQUN6QlAsU0FBUyxDQUFDLEVBQUUsR0FBR00sRUFBRUUsS0FBSyxLQUFLLE9BQU87UUFDbENILEVBQUViLFdBQVcsQ0FBQ0MsUUFBUSxNQUFNLElBQUlnQixJQUFJLENBQUNULFdBQVc7SUFDcEQsT0FDSztRQUNEQSxZQUFZUCxPQUFPYyxLQUFLLENBQUM7UUFDekJQLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDZkssRUFBRWIsV0FBVyxDQUFDQyxRQUFRLE1BQU0sSUFBSWdCLElBQUksQ0FBQ1QsV0FBVztRQUNoRE0sRUFBRWQsV0FBVyxDQUFDQyxRQUFRLE1BQU0sSUFBSWdCLElBQUksQ0FBQ1QsV0FBVztJQUNwRDtJQUNBLE9BQU9BO0FBQ1gsR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxdjMtbGliL2luZGV4LmpzPzAyOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgZnJvbSBzZWNwMjU2azEgdjNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG52YXIgZWNwYXJhbXMgPSBlYy5jdXJ2ZTtcbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuICAgIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICAgIGlmIChkLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBleHBvcnQgdG8gREVSIGZvcm1hdFwiKTtcbiAgICB9XG4gICAgdmFyIHBvaW50ID0gZWMuZy5tdWwoZCk7XG4gICAgcmV0dXJuIHRvUHVibGljS2V5KHBvaW50LmdldFgoKSwgcG9pbnQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICB2YXIgYm4gPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gICAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IHJhbmdlIGlzIGludmFsaWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICAgIGlmIChyLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgICAgICByID0gbmV3IEJOKDApO1xuICAgIH1cbiAgICB2YXIgcyA9IG5ldyBCTihzaWdPYmoucyk7XG4gICAgaWYgKHMudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgICAgIHMgPSBuZXcgQk4oMCk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtyLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLCBzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXSk7XG59O1xuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IHRydWU7IH1cbiAgICB2YXIgcG9pbnQgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleSk7XG4gICAgdmFyIHNjYWxhciA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgICBpZiAoc2NhbGFyLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsYXIgd2FzIGludmFsaWQgKHplcm8gb3Igb3ZlcmZsb3cpJyk7XG4gICAgfVxuICAgIHZhciBzaGFyZWQgPSBwb2ludC5wdWIubXVsKHNjYWxhcik7XG4gICAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcbnZhciB0b1B1YmxpY0tleSA9IGZ1bmN0aW9uICh4LCB5LCBjb21wcmVzc2VkKSB7XG4gICAgdmFyIHB1YmxpY0tleTtcbiAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoMzMpO1xuICAgICAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICAgICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgICAgICBwdWJsaWNLZXlbMF0gPSAweDA0O1xuICAgICAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgICAgICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljS2V5O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJOIiwicmVxdWlyZSIsIkVDIiwiZWMiLCJlY3BhcmFtcyIsImN1cnZlIiwicHJpdmF0ZUtleUV4cG9ydCIsInByaXZhdGVLZXkiLCJjb21wcmVzc2VkIiwiZCIsInVjbXAiLCJuIiwiRXJyb3IiLCJwb2ludCIsImciLCJtdWwiLCJ0b1B1YmxpY0tleSIsImdldFgiLCJnZXRZIiwicHJpdmF0ZUtleU1vZEludmVyc2UiLCJibiIsImlzWmVybyIsImludm0iLCJ0b0FycmF5TGlrZSIsIkJ1ZmZlciIsInNpZ25hdHVyZUltcG9ydCIsInNpZ09iaiIsInIiLCJzIiwiY29uY2F0IiwiZWNkaFVuc2FmZSIsInB1YmxpY0tleSIsImtleUZyb21QdWJsaWMiLCJzY2FsYXIiLCJzaGFyZWQiLCJwdWIiLCJ4IiwieSIsImFsbG9jIiwiaXNPZGQiLCJjb3B5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;\nvar secp256k1 = __webpack_require__(/*! ./secp256k1v3-adapter */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/secp256k1v3-adapter.js\");\nvar BN = __webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/bn.js/lib/bn.js\");\nvar bytes_1 = __webpack_require__(/*! ./bytes */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/bytes.js\");\nvar hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/hash.js\");\n/**\n * Returns the ECDSA signature of a message hash.\n */ exports.ecsign = function(msgHash, privateKey, chainId) {\n    var sig = secp256k1.sign(msgHash, privateKey);\n    var recovery = sig.recovery;\n    var ret = {\n        r: sig.signature.slice(0, 32),\n        s: sig.signature.slice(32, 64),\n        v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27\n    };\n    return ret;\n};\n/**\n * ECDSA public key recovery from signature.\n * @returns Recovered public key\n */ exports.ecrecover = function(msgHash, v, r, s, chainId) {\n    var signature = Buffer.concat([\n        bytes_1.setLength(r, 32),\n        bytes_1.setLength(s, 32)\n    ], 64);\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    var senderPubKey = secp256k1.recover(msgHash, signature, recovery);\n    return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);\n};\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * @returns Signature\n */ exports.toRpcSig = function(v, r, s, chainId) {\n    var recovery = calculateSigRecovery(v, chainId);\n    if (!isValidSigRecovery(recovery)) {\n        throw new Error(\"Invalid signature v value\");\n    }\n    // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n    return bytes_1.bufferToHex(Buffer.concat([\n        bytes_1.setLengthLeft(r, 32),\n        bytes_1.setLengthLeft(s, 32),\n        bytes_1.toBuffer(v)\n    ]));\n};\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053\n */ exports.fromRpcSig = function(sig) {\n    var buf = bytes_1.toBuffer(sig);\n    // NOTE: with potential introduction of chainId this might need to be updated\n    if (buf.length !== 65) {\n        throw new Error(\"Invalid signature length\");\n    }\n    var v = buf[64];\n    // support both versions of `eth_sign` responses\n    if (v < 27) {\n        v += 27;\n    }\n    return {\n        v: v,\n        r: buf.slice(0, 32),\n        s: buf.slice(32, 64)\n    };\n};\n/**\n * Validate a ECDSA signature.\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */ exports.isValidSignature = function(v, r, s, homesteadOrLater, chainId) {\n    if (homesteadOrLater === void 0) {\n        homesteadOrLater = true;\n    }\n    var SECP256K1_N_DIV_2 = new BN(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16);\n    var SECP256K1_N = new BN(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n    if (r.length !== 32 || s.length !== 32) {\n        return false;\n    }\n    if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n        return false;\n    }\n    var rBN = new BN(r);\n    var sBN = new BN(s);\n    if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {\n        return false;\n    }\n    if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */ exports.hashPersonalMessage = function(message) {\n    var prefix = Buffer.from(\"\\x19Ethereum Signed Message:\\n\" + message.length.toString(), \"utf-8\");\n    return hash_1.keccak(Buffer.concat([\n        prefix,\n        message\n    ]));\n};\nfunction calculateSigRecovery(v, chainId) {\n    return chainId ? v - (2 * chainId + 35) : v - 27;\n}\nfunction isValidSigRecovery(recovery) {\n    return recovery === 0 || recovery === 1;\n} //# sourceMappingURL=signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy1hYmkvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGlCQUFpQixHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUMzSSxJQUFJUSxZQUFZQyxtQkFBT0EsQ0FBQztBQUN4QixJQUFJQyxLQUFLRCxtQkFBT0EsQ0FBQyxtREFBTztBQUN4QixJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQywrRkFBUztBQUMvQixJQUFJRyxTQUFTSCxtQkFBT0EsQ0FBQyw2RkFBUTtBQUM3Qjs7Q0FFQyxHQUNEVCxjQUFjLEdBQUcsU0FBVWEsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLE9BQU87SUFDbkQsSUFBSUMsTUFBTVIsVUFBVVMsSUFBSSxDQUFDSixTQUFTQztJQUNsQyxJQUFJSSxXQUFXRixJQUFJRSxRQUFRO0lBQzNCLElBQUlDLE1BQU07UUFDTkMsR0FBR0osSUFBSUssU0FBUyxDQUFDQyxLQUFLLENBQUMsR0FBRztRQUMxQkMsR0FBR1AsSUFBSUssU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSTtRQUMzQkUsR0FBR1QsVUFBVUcsV0FBWUgsQ0FBQUEsVUFBVSxJQUFJLEVBQUMsSUFBS0csV0FBVztJQUM1RDtJQUNBLE9BQU9DO0FBQ1g7QUFDQTs7O0NBR0MsR0FDRG5CLGlCQUFpQixHQUFHLFNBQVVhLE9BQU8sRUFBRVcsQ0FBQyxFQUFFSixDQUFDLEVBQUVHLENBQUMsRUFBRVIsT0FBTztJQUNuRCxJQUFJTSxZQUFZSSxPQUFPQyxNQUFNLENBQUM7UUFBQ2YsUUFBUWdCLFNBQVMsQ0FBQ1AsR0FBRztRQUFLVCxRQUFRZ0IsU0FBUyxDQUFDSixHQUFHO0tBQUksRUFBRTtJQUNwRixJQUFJ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IjpbIndlYnBhY2s6Ly90aGVmcm9udC8uL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLWFiaS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2lnbmF0dXJlLmpzPzVlODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBleHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBleHBvcnRzLmZyb21ScGNTaWcgPSBleHBvcnRzLnRvUnBjU2lnID0gZXhwb3J0cy5lY3JlY292ZXIgPSBleHBvcnRzLmVjc2lnbiA9IHZvaWQgMDtcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMXYzLWFkYXB0ZXInKTtcbnZhciBCTiA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbnZhciBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgRUNEU0Egc2lnbmF0dXJlIG9mIGEgbWVzc2FnZSBoYXNoLlxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5LCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuICAgIHZhciByZWNvdmVyeSA9IHNpZy5yZWNvdmVyeTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICByOiBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpLFxuICAgICAgICB2OiBjaGFpbklkID8gcmVjb3ZlcnkgKyAoY2hhaW5JZCAqIDIgKyAzNSkgOiByZWNvdmVyeSArIDI3LFxuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbn07XG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBSZWNvdmVyZWQgcHVibGljIGtleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzLCBjaGFpbklkKSB7XG4gICAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2J5dGVzXzEuc2V0TGVuZ3RoKHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICAgIHZhciByZWNvdmVyeSA9IGNhbGN1bGF0ZVNpZ1JlY292ZXJ5KHYsIGNoYWluSWQpO1xuICAgIGlmICghaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgICB9XG4gICAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZC5cbiAqIEByZXR1cm5zIFNpZ25hdHVyZVxuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMsIGNoYWluSWQpIHtcbiAgICB2YXIgcmVjb3ZlcnkgPSBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKTtcbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShyZWNvdmVyeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gICAgfVxuICAgIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gICAgcmV0dXJuIGJ5dGVzXzEuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgYnl0ZXNfMS5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgYnl0ZXNfMS50b0J1ZmZlcih2KV0pKTtcbn07XG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICAgIHZhciBidWYgPSBieXRlc18xLnRvQnVmZmVyKHNpZyk7XG4gICAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgICBpZiAoYnVmLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgICB9XG4gICAgdmFyIHYgPSBidWZbNjRdO1xuICAgIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICAgIGlmICh2IDwgMjcpIHtcbiAgICAgICAgdiArPSAyNztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgcjogYnVmLnNsaWNlKDAsIDMyKSxcbiAgICAgICAgczogYnVmLnNsaWNlKDMyLCA2NCksXG4gICAgfTtcbn07XG4vKipcbiAqIFZhbGlkYXRlIGEgRUNEU0Egc2lnbmF0dXJlLlxuICogQHBhcmFtIGhvbWVzdGVhZE9yTGF0ZXIgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBiZWluZyB1c2VkIG9uIGVpdGhlciB0aGUgaG9tZXN0ZWFkIGhhcmRmb3JrIG9yIGEgbGF0ZXIgb25lXG4gKi9cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWRPckxhdGVyLCBjaGFpbklkKSB7XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgPT09IHZvaWQgMCkgeyBob21lc3RlYWRPckxhdGVyID0gdHJ1ZTsgfVxuICAgIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRTaWdSZWNvdmVyeShjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgckJOID0gbmV3IEJOKHIpO1xuICAgIHZhciBzQk4gPSBuZXcgQk4ocyk7XG4gICAgaWYgKHJCTi5pc1plcm8oKSB8fCByQk4uZ3QoU0VDUDI1NksxX04pIHx8IHNCTi5pc1plcm8oKSB8fCBzQk4uZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhvbWVzdGVhZE9yTGF0ZXIgJiYgc0JOLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHZhciBwcmVmaXggPSBCdWZmZXIuZnJvbShcIlxcdTAwMTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIiArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCksICd1dGYtOCcpO1xuICAgIHJldHVybiBoYXNoXzEua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVTaWdSZWNvdmVyeSh2LCBjaGFpbklkKSB7XG4gICAgcmV0dXJuIGNoYWluSWQgPyB2IC0gKDIgKiBjaGFpbklkICsgMzUpIDogdiAtIDI3O1xufVxuZnVuY3Rpb24gaXNWYWxpZFNpZ1JlY292ZXJ5KHJlY292ZXJ5KSB7XG4gICAgcmV0dXJuIHJlY292ZXJ5ID09PSAwIHx8IHJlY292ZXJ5ID09PSAxO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImhhc2hQZXJzb25hbE1lc3NhZ2UiLCJpc1ZhbGlkU2lnbmF0dXJlIiwiZnJvbVJwY1NpZyIsInRvUnBjU2lnIiwiZWNyZWNvdmVyIiwiZWNzaWduIiwic2VjcDI1NmsxIiwicmVxdWlyZSIsIkJOIiwiYnl0ZXNfMSIsImhhc2hfMSIsIm1zZ0hhc2giLCJwcml2YXRlS2V5IiwiY2hhaW5JZCIsInNpZyIsInNpZ24iLCJyZWNvdmVyeSIsInJldCIsInIiLCJzaWduYXR1cmUiLCJzbGljZSIsInMiLCJ2IiwiQnVmZmVyIiwiY29uY2F0Iiwic2V0TGVuZ3RoIiwiY2FsY3VsYXRlU2lnUmVjb3ZlcnkiLCJpc1ZhbGlkU2lnUmVjb3ZlcnkiLCJFcnJvciIsInNlbmRlclB1YktleSIsInJlY292ZXIiLCJwdWJsaWNLZXlDb252ZXJ0IiwiYnVmZmVyVG9IZXgiLCJzZXRMZW5ndGhMZWZ0IiwidG9CdWZmZXIiLCJidWYiLCJsZW5ndGgiLCJob21lc3RlYWRPckxhdGVyIiwiU0VDUDI1NksxX05fRElWXzIiLCJTRUNQMjU2SzFfTiIsInJCTiIsInNCTiIsImlzWmVybyIsImd0IiwiY21wIiwibWVzc2FnZSIsInByZWZpeCIsImZyb20iLCJ0b1N0cmluZyIsImtlY2NhayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ethereumjs-abi/node_modules/ethereumjs-util/dist/signature.js\n");

/***/ })

};
;